<#
.SYNOPSIS
    Generates markdown documentation from XML documentation comments
.DESCRIPTION
    Uses the XML documentation file generated by the C# compiler to create
    markdown reference documentation. This is more reliable than parsing source code.
.PARAMETER XmlDocFile
    Path to the XML documentation file (e.g., bin/Debug/net9.0/YoFi.V3.Tests.Functional.xml)
.PARAMETER OutputFile
    Path to the output markdown file
.PARAMETER NamespaceFilter
    Filter to specific namespace (e.g., "YoFi.V3.Tests.Functional.Generated")
#>
param(
    [Parameter(Mandatory=$true)]
    [string]$XmlDocFile,

    [Parameter(Mandatory=$true)]
    [string]$OutputFile,

    [string]$NamespaceFilter = ""
)

$ErrorActionPreference = "Stop"

Write-Host "Generating documentation from XML..." -ForegroundColor Cyan
Write-Host "Source: $XmlDocFile" -ForegroundColor Gray
Write-Host "Output: $OutputFile" -ForegroundColor Gray

# Check if XML doc file exists
if (-not (Test-Path $XmlDocFile)) {
    Write-Error "XML documentation file not found: $XmlDocFile"
    Write-Host "`nTo generate XML documentation:" -ForegroundColor Yellow
    Write-Host "1. Add to .csproj: <GenerateDocumentationFile>true</GenerateDocumentationFile>" -ForegroundColor Yellow
    Write-Host "2. Build the project: dotnet build" -ForegroundColor Yellow
    exit 1
}

# Load XML documentation
[xml]$xmlDoc = Get-Content $XmlDocFile

# Extract members
$types = @{}
$currentType = $null

foreach ($member in $xmlDoc.doc.members.member) {
    $name = $member.name

    # Parse member type (T:Type, M:Method, P:Property, F:Field)
    if ($name -match '^([TMPF]):(.+)') {
        $memberType = $Matches[1]
        $fullName = $Matches[2]

        # Apply namespace filter
        if ($NamespaceFilter -and $fullName -notmatch [regex]::Escape($NamespaceFilter)) {
            continue
        }

        # Get summary
        $summary = if ($member.summary) {
            ($member.summary -replace '^\s+|\s+$', '' -replace '\s+', ' ').Trim()
        } else {
            ""
        }

        # Get remarks
        $remarks = if ($member.remarks) {
            ($member.remarks -replace '^\s+|\s+$', '' -replace '\s+', ' ').Trim()
        } else {
            ""
        }

        # Get parameters
        $params = @{}
        if ($member.param) {
            foreach ($param in $member.param) {
                $paramName = $param.name
                $paramDesc = ($param.'#text' -replace '^\s+|\s+$', '' -replace '\s+', ' ').Trim()
                $params[$paramName] = $paramDesc
            }
        }

        # Get return value
        $returns = if ($member.returns) {
            ($member.returns -replace '^\s+|\s+$', '' -replace '\s+', ' ').Trim()
        } else {
            ""
        }

        switch ($memberType) {
            'T' {
                # Type (class, interface, enum)
                $typeName = $fullName -replace '.*\.', ''

                if (-not $types.ContainsKey($typeName)) {
                    $types[$typeName] = @{
                        FullName = $fullName
                        Summary = $summary
                        Remarks = $remarks
                        Methods = @()
                        Properties = @()
                    }
                }
                $currentType = $typeName
            }
            'M' {
                # Method
                if ($fullName -match '([^.]+)\.([^.(]+)(\(.*\))?$') {
                    $className = $Matches[1] -replace '.*\.', ''
                    $methodName = $Matches[2]
                    $signature = if ($Matches[3]) { $Matches[3] } else { "()" }

                    if (-not $types.ContainsKey($className)) {
                        $types[$className] = @{
                            FullName = $fullName -replace '\.[^.]+$', ''
                            Summary = ""
                            Remarks = ""
                            Methods = @()
                            Properties = @()
                        }
                    }

                    $types[$className].Methods += @{
                        Name = $methodName
                        Signature = $signature
                        Summary = $summary
                        Remarks = $remarks
                        Parameters = $params
                        Returns = $returns
                    }
                }
            }
            'P' {
                # Property
                if ($fullName -match '([^.]+)\.([^.]+)$') {
                    $className = $Matches[1] -replace '.*\.', ''
                    $propertyName = $Matches[2]

                    if (-not $types.ContainsKey($className)) {
                        $types[$className] = @{
                            FullName = $fullName -replace '\.[^.]+$', ''
                            Summary = ""
                            Remarks = ""
                            Methods = @()
                            Properties = @()
                        }
                    }

                    $types[$className].Properties += @{
                        Name = $propertyName
                        Summary = $summary
                    }
                }
            }
        }
    }
}

# Generate markdown
$markdown = @"
# API Documentation

**Generated from:** XML Documentation Comments
**Namespace:** $NamespaceFilter

---

"@

# Sort types - interfaces first, then classes
$interfaces = $types.Keys | Where-Object { $_ -like 'I*Client' } | Sort-Object
$classes = $types.Keys | Where-Object { $_ -notlike 'I*Client' -and $_ -notlike '*Exception' } | Sort-Object
$exceptions = $types.Keys | Where-Object { $_ -like '*Exception' } | Sort-Object

if ($interfaces.Count -gt 0) {
    $markdown += "## Client Interfaces`n`n"

    foreach ($typeName in $interfaces) {
        $type = $types[$typeName]

        $markdown += "### $typeName`n`n"

        if ($type.Summary) {
            $markdown += "$($type.Summary)`n`n"
        }

        if ($type.Remarks) {
            $markdown += "> $($type.Remarks)`n`n"
        }

        if ($type.Methods.Count -gt 0) {
            $markdown += "**Methods:**`n`n"

            # Group methods by base name (exclude cancellation token overloads)
            $methodGroups = @{}
            foreach ($method in $type.Methods) {
                $baseName = $method.Name -replace 'Async$', ''
                if (-not $methodGroups.ContainsKey($baseName)) {
                    $methodGroups[$baseName] = $method
                }
            }

            foreach ($baseName in $methodGroups.Keys | Sort-Object) {
                $method = $methodGroups[$baseName]

                $markdown += "#### $($method.Name)`n`n"

                if ($method.Summary) {
                    $markdown += "$($method.Summary)`n`n"
                }

                if ($method.Parameters.Count -gt 0) {
                    $markdown += "**Parameters:**`n`n"
                    foreach ($param in $method.Parameters.Keys | Sort-Object) {
                        $markdown += "- ``$param``: $($method.Parameters[$param])`n"
                    }
                    $markdown += "`n"
                }

                if ($method.Returns) {
                    $markdown += "**Returns:** $($method.Returns)`n`n"
                }

                if ($method.Remarks) {
                    $markdown += "> $($method.Remarks)`n`n"
                }
            }
        }

        $markdown += "---`n`n"
    }
}

if ($classes.Count -gt 0) {
    $markdown += "## Data Models`n`n"

    foreach ($typeName in $classes) {
        $type = $types[$typeName]

        $markdown += "### $typeName`n`n"

        if ($type.Summary) {
            $markdown += "$($type.Summary)`n`n"
        }

        if ($type.Remarks) {
            $markdown += "> $($type.Remarks)`n`n"
        }

        if ($type.Properties.Count -gt 0) {
            $markdown += "**Properties:**`n`n"
            foreach ($prop in $type.Properties | Sort-Object Name) {
                $markdown += "- ``$($prop.Name)``"
                if ($prop.Summary) {
                    $markdown += " - $($prop.Summary)"
                }
                $markdown += "`n"
            }
            $markdown += "`n"
        }

        $markdown += "---`n`n"
    }
}

# Write output
$markdown | Out-File -FilePath $OutputFile -Encoding UTF8 -NoNewline

Write-Host "`nDocumentation generated successfully!" -ForegroundColor Green
Write-Host "Output file: $OutputFile" -ForegroundColor Gray
Write-Host "`nTypes documented: $($types.Count)" -ForegroundColor Gray
Write-Host "- Interfaces: $($interfaces.Count)" -ForegroundColor Gray
Write-Host "- Classes: $($classes.Count)" -ForegroundColor Gray
