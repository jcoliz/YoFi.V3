# Functional Tests Rules

## Important: One Scenario at a Time + Source Generation

**CRITICAL WORKFLOW RULES:**

1. **One scenario at a time**: ALWAYS implement one scenario from start to finish before moving to the next. Add ONE scenario → Generate → Implement steps → Implement POM methods → Iterate to passing → Commit. Then and only then move to the next scenario.

2. **Test implementations are auto-generated**: Test implementations are automatically generated by C# source generation at build time. NEVER manually create or edit `*.feature.g.cs` files or anything in `obj/GeneratedFiles/`.

3. **Step definitions vs Generated tests**:
   - **Step definitions** = Manually created in `Steps/` directory (you create these)
   - **Test implementations** = Auto-generated in `obj/GeneratedFiles/` (source generator creates these)
   - **Feature files** = Manually created in `Features/` directory (you create these in Gherkin)

When asked to "confirm steps exist and create missing steps":
- **DO**: Check if step methods exist in the `Steps/` directory
- **DO**: Create any missing step method implementations in `Steps/`
- **DO NOT**: Manually create or edit `*.feature.g.cs` files - they are auto-generated
- **DO NOT**: Create or edit any files in `obj/GeneratedFiles/` - they are build artifacts

## Generating Test Implementations from Feature Files

**Test implementations are automatically generated at build time using C# source generation. DO NOT create or edit `.feature.cs` or `.feature.g.cs` files manually.**

### Source Generation Process

The project uses [Gherkin.Generator](https://github.com/jcoliz/Gherkin.Generator) to automatically generate C# test implementations from Gherkin feature files:

1. **Automatic Generation**: When you build the project (`dotnet build`), the source generator processes all `*.feature` files in [`Features/`](../Features/)
2. **Generated Location**: Generated files are placed in `obj/GeneratedFiles/Gherkin.Generator/Gherkin.Generator.GherkinSourceGenerator/`
3. **Not Source Controlled**: Generated files are NOT checked into source control - they only exist in the `obj/` directory
4. **File Naming**: Each `{Feature}.feature` file generates a `{Feature}.g.cs` file with the test implementations

### Configuration

The source generator is configured via NuGet package reference in [`YoFi.V3.Tests.Functional.csproj`](../YoFi.V3.Tests.Functional.csproj):

```xml
<PackageReference Include="Gherkin.Generator" Version="0.1.5" />
<Using Include="Gherkin.Generator.Utils" />
```

### Generated Code Structure

The source generator analyzes your feature files and step definitions to produce:

- **Test Class**: One test fixture class per feature file
- **Test Methods**: One test method per scenario (or `[TestCase]` attributes for scenario outlines)
- **Step Calls**: Each Gherkin step becomes a method call to the corresponding step definition
- **Stub Generation**: For unimplemented steps, the generator creates stub methods in the `.g.cs` file with `NotImplementedException`

### Workflow for Adding New Tests

**CRITICAL: Always implement ONE scenario at a time from start to finish. Never work on multiple scenarios simultaneously.**

**For each single scenario:**

1. **Write ONE scenario**: Add ONE scenario to a `.feature` file in [`Features/`](../Features/)
2. **Build the project**: Run `dotnet build` to trigger source generation
3. **Check generated file**: Look in `obj/GeneratedFiles/Gherkin.Generator/Gherkin.Generator.GherkinSourceGenerator/{Feature}.g.cs`
4. **Find stub methods**: Unimplemented steps for THIS scenario will have stub methods with `NotImplementedException`
5. **Copy stubs to Steps**: Copy ONLY the stub methods for THIS scenario into appropriate step definition classes in [`Steps/`](../Steps/)
6. **Implement steps**: Implement ONLY the steps needed for THIS scenario
7. **Create POM methods**: Create ONLY the Page Object Model methods needed for THESE steps
8. **Rebuild**: Run `dotnet build` again - stubs should disappear from generated file once steps are implemented
9. **Iterate test to passing**: Run `dotnet test --filter {ScenarioMethod}` repeatedly, fixing issues until THIS scenario passes
10. **Commit**: Once THIS scenario passes, commit the code before starting the next scenario

**Never move to the next scenario until the current one is complete, passing, and committed.**

### Example Generated Code Structure

**Feature file** ([`Authentication.feature`](../Features/Authentication.feature)):
```gherkin
Feature: User Authentication
    Users can log in and log out of the application

    Scenario: User logs in successfully
        Given I am on the login page
        When I enter valid credentials
        And I click the login button
        Then I should be redirected to the home page
```

**Generated test class** (in `obj/GeneratedFiles/.../Authentication.g.cs`):
```csharp
[TestFixture]
public partial class AuthenticationTests : AuthenticationSteps
{
    /// <summary>
    /// User logs in successfully
    /// </summary>
    [Test]
    public async Task UserLogsInSuccessfully()
    {
        // Given I am on the login page
        await GivenIAmOnTheLoginPage();

        // When I enter valid credentials
        await WhenIEnterValidCredentials();

        // And I click the login button
        await WhenIClickTheLoginButton();

        // Then I should be redirected to the home page
        await ThenIShouldBeRedirectedToTheHomePage();
    }
}
```

**If a step is missing**, the generator creates a stub:
```csharp
[Given("I am on the login page")]
protected async Task GivenIAmOnTheLoginPage()
{
    throw new NotImplementedException("Step 'Given I am on the login page' is not implemented");
}
```

### Key Features of the Generator

- **Automatic step matching**: Matches Gherkin steps to C# methods via `[Given]`, `[When]`, `[Then]` attributes
- **Parameter extraction**: Extracts parameters from steps using `{paramName}` placeholders
- **DataTable support**: Converts Gherkin tables to `DataTable` objects from `Gherkin.Generator.Utils`
- **Scenario Outlines**: Generates `[TestCase]` attributes for each Examples row
- **Background support**: Converts Background sections to `[SetUp]` methods
- **Stub generation**: Creates stub methods for unimplemented steps
- **Compile-time checking**: Build errors occur if step definitions don't match feature files

## Gherkin Step Implementation

When implementing or updating step methods in the `Steps/` directory:

### Step Attribute Pattern Matching (CRITICAL)

1. **Step Attributes Are Authoritative - Method Names Are Irrelevant**: The step attribute (`[Given]`, `[When]`, `[Then]`) is the ONLY thing that matters for matching Gherkin steps to methods. Method names are for code readability only.
   - ✅ CORRECT: Match steps ONLY by attribute: `[Then("I should see an error message containing {errorMessage}")]`
   - ❌ WRONG: Assume method must be named `ThenIShouldSeeAnErrorMessageContaining`
   - **There is ABSOLUTELY NO expectation or requirement that method names match step patterns**
   - Method names should be clear and concise for developers, NOT mirror the Gherkin text
   - This separation allows refactoring method names without breaking step matching

2. **Multiple Step Patterns in One Method**: A single method can match multiple Gherkin step patterns by including multiple step attributes (using `AllowMultiple = true`).
   - Use this to consolidate duplicate/alias methods into a single implementation
   - Each attribute represents a different step pattern that maps to this method

   **Example:**
   ```csharp
   /// <summary>
   /// Establishes that the user owns a workspace.
   /// </summary>
   [Given("I have a workspace called {workspaceName}")]
   [Given("I own a workspace called {workspaceName}")]
   [Given("I own {workspaceName}")]
   protected async Task GivenIHaveAWorkspaceCalled(string workspaceName)
   {
       // Single implementation handles all three step variations
   }
   ```

   **Benefits:**
   - Reduces code duplication when steps have identical behavior
   - Keeps related step variations together
   - Makes refactoring easier (change implementation once, affects all patterns)

   **When to use:**
   - Steps are semantically identical (e.g., "I own X" = "I have X" for Owner role)
   - Steps are just shortened versions (e.g., "I own X" is shorthand for "I have a workspace called X")
   - Different phrasings of the same action

   **When NOT to use:**
   - Steps have different semantics even if implementation is similar
   - Steps might diverge in behavior later
   - Clarity would be compromised

3. **Exact Matching Required**: Each attribute pattern must match its Gherkin step text exactly, including all words and adverbs.
   - ✅ CORRECT: `[When("I try to navigate directly to the login page")]` matches Gherkin step exactly
   - ❌ WRONG: Assuming `[When("I try to navigate to the login page")]` matches when Gherkin says "directly"
   - **Why**: Words like "directly" may indicate different behavior (e.g., bypass redirects, force navigation)
   - If similar steps exist with slightly different wording, create a new step method with the exact pattern

4. **Method Names Should Be Clear, Not Literal**: Method names should be descriptive for code maintainability, NOT verbatim copies of Gherkin steps.
   - **Good**: `[When("I try to navigate directly to the login page")]` → Method `WhenITryToNavigateToLoginPage()`
   - **Bad**: `[When("I try to navigate directly to the login page")]` → Method `WhenITryToNavigateDirectlyToTheLoginPage()`
   - **Good**: `[Then("I should see an error message containing {errorMessage}")]` → Method `ThenIShouldSeeAnErrorMessage(string message)`
   - **Bad**: `[Then("I should see an error message containing {errorMessage}")]` → Method `ThenIShouldSeeAnErrorMessageContaining(string message)`
   - Keep method names concise - omit words like "directly", "containing", "exactly" if they don't add clarity
   - The attribute pattern captures the exact step text; the method name serves code readability

5. **Creating New Step Methods**:
   - Add the appropriate step attribute (`[Given]`, `[When]`, or `[Then]`) with a pattern matching the **exact** Gherkin step text word-for-word
   - Include all adverbs, adjectives, and qualifiers from the Gherkin step
   - Use placeholders like `{text}`, `{value}`, `{parameterName}` for parameters
   - For steps with DataTable parameters, add a trailing colon `:` to the pattern
   - Method name should be descriptive but doesn't need to include every word if clear from context
   - XML comments remain for human-readable documentation

6. **Finding Existing Steps**:
   - Always search for methods by their step attribute pattern first
   - Use `search_files` to find methods by attribute pattern: `\[Given\("pattern"\)\]`
   - Don't create duplicate methods just because the name doesn't match exactly
   - **Do** create a new method if no attribute matches the Gherkin step exactly
   - Use [`scripts/Analyze-StepPatterns.ps1`](../../scripts/Analyze-StepPatterns.ps1) to verify no duplicate patterns exist

### Examples

```csharp
// ✅ CORRECT: Attribute pattern matches Gherkin, method name is concise, XML comment for documentation
/// <summary>
/// Verifies that an error message containing specific text is displayed.
/// </summary>
/// <param name="errorMessage">The expected error message text (or substring).</param>
[Then("I should see an error message containing {errorMessage}")]
protected async Task ThenIShouldSeeAnErrorMessage(string errorMessage)
{
    // Implementation
}

// ❌ WRONG: Unnecessarily verbose method name (attribute pattern is fine)
/// <summary>
/// Verifies that an error message containing specific text is displayed.
/// </summary>
[Then("I should see an error message containing {errorMessage}")]
protected async Task ThenIShouldSeeAnErrorMessageContaining(string errorMessage)
{
    // This creates confusion and is redundant
}

// ✅ CORRECT: Multiple attributes for step variations
/// <summary>
/// Establishes that the user owns a workspace with the specified name.
/// </summary>
[Given("{username} owns a workspace called {workspaceName}")]
[Given("{username} owns {workspaceName}")]
protected async Task GivenUserOwnsAWorkspaceCalled(string username, string workspaceName)
{
    // Single implementation handles both patterns
}

// ✅ CORRECT: DataTable step with trailing colon
/// <summary>
/// Sets up multiple workspace access assignments from a table.
/// </summary>
[Given("{username} has access to these workspaces:")]
protected async Task GivenUserHasAccessToTheseWorkspaces(string username, DataTable workspacesTable)
{
    // Process table data
}
```

### Step Method Organization

- Place GIVEN steps in `#region Steps: GIVEN`
- Place WHEN steps in `#region Steps: WHEN`
- Place THEN steps in `#region Steps: THEN`
- Keep helper methods in `#region Helpers`

### Parameter Handling

- Use DataTable for tabular data from Gherkin
- Extract quoted strings as separate parameters
- Support both parameterless and parameterized overloads when needed

## See Also

- [docs/WRITING-TESTS.md](../docs/WRITING-TESTS.md) - Complete handbook for writing functional tests
- [Gherkin.Generator](https://github.com/jcoliz/Gherkin.Generator) - Source generator documentation
- [README.md](../README.md) - Functional test principles and getting started
