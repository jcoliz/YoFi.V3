using Microsoft.EntityFrameworkCore;
using YoFi.V3.Data;
using YoFi.V3.Entities.Models;
using YoFi.V3.Entities.Tenancy.Models;

namespace YoFi.V3.Tests.Integration.Data;

/// <summary>
/// Integration tests for PayeeMatchingRule entity and tenant-scoped data operations.
/// These tests verify database behavior, tenant isolation, EF Core configuration,
/// and DateTimeOffset handling for SQLite.
/// </summary>
public class PayeeMatchingRuleTests
{
    private ApplicationDbContext _context;
    private DbContextOptions<ApplicationDbContext> _options;
    private Tenant _tenant1;
    private Tenant _tenant2;

    [SetUp]
    public async Task Setup()
    {
        // Given: An in-memory database for testing
        _options = new DbContextOptionsBuilder<ApplicationDbContext>()
            .UseSqlite("DataSource=:memory:")
            .Options;

        _context = new ApplicationDbContext(_options);
        _context.Database.OpenConnection(); // Keep in-memory DB alive
        _context.Database.EnsureCreated();

        // And: Test tenants
        _tenant1 = new Tenant { Name = "Tenant 1", Description = "First test tenant" };
        _tenant2 = new Tenant { Name = "Tenant 2", Description = "Second test tenant" };
        _context.Tenants.AddRange(_tenant1, _tenant2);
        await _context.SaveChangesAsync();
    }

    [TearDown]
    public void TearDown()
    {
        _context.Database.CloseConnection();
        _context.Dispose();
    }

    [Test]
    public async Task PayeeMatchingRule_HasCorrectTableName()
    {
        // Given: A payee matching rule
        var rule = new PayeeMatchingRule
        {
            PayeePattern = "Amazon",
            Category = "Shopping",
            TenantId = _tenant1.Id
        };

        _context.PayeeMatchingRules.Add(rule);
        await _context.SaveChangesAsync();

        // When: Checking the table name in the database
        var connection = _context.Database.GetDbConnection();
        await connection.OpenAsync();
        using var command = connection.CreateCommand();
        command.CommandText = "SELECT name FROM sqlite_master WHERE type='table' AND name='YoFi.V3.PayeeMatchingRules'";
        var tableName = await command.ExecuteScalarAsync();

        // Then: The table should exist with the correct name
        Assert.That(tableName, Is.EqualTo("YoFi.V3.PayeeMatchingRules"));
    }

    [Test]
    public async Task PayeeMatchingRule_IdIsAutoGenerated_KeyIsPreset()
    {
        // Given: A rule without Id explicitly set
        var rule = new PayeeMatchingRule
        {
            PayeePattern = "Starbucks",
            Category = "Coffee",
            TenantId = _tenant1.Id
        };

        Assert.That(rule.Id, Is.EqualTo(0)); // Initially zero
        var initialKey = rule.Key;
        Assert.That(initialKey, Is.Not.EqualTo(Guid.Empty)); // Key is auto-generated on construction

        // When: Adding and saving the rule
        _context.PayeeMatchingRules.Add(rule);
        await _context.SaveChangesAsync();

        // Then: Id should be auto-generated, Key should remain the same
        Assert.That(rule.Id, Is.GreaterThan(0));
        Assert.That(rule.Key, Is.EqualTo(initialKey)); // Key doesn't change
        Assert.That(rule.Key, Is.Not.EqualTo(Guid.Empty));
    }

    [Test]
    public async Task PayeeMatchingRule_TenantIdIsRequired()
    {
        // Given: A rule without a TenantId (0 is invalid for foreign key)
        var rule = new PayeeMatchingRule
        {
            PayeePattern = "Test",
            Category = "Test Category",
            TenantId = 0 // Invalid
        };

        _context.PayeeMatchingRules.Add(rule);

        // When/Then: Saving should fail with a database constraint error
        Assert.ThrowsAsync<DbUpdateException>(async () => await _context.SaveChangesAsync());
    }

    [Test]
    public async Task PayeeMatchingRule_TenantIdForeignKeyConstraint()
    {
        // Given: A rule with a non-existent TenantId
        var rule = new PayeeMatchingRule
        {
            PayeePattern = "Test",
            Category = "Test Category",
            TenantId = 999999 // Non-existent tenant
        };

        _context.PayeeMatchingRules.Add(rule);

        // When/Then: Saving should fail due to foreign key constraint
        Assert.ThrowsAsync<DbUpdateException>(async () => await _context.SaveChangesAsync());
    }

    [Test]
    public async Task PayeeMatchingRule_CanQueryByTenantId()
    {
        // Given: Rules for multiple tenants
        _context.PayeeMatchingRules.AddRange(
            new PayeeMatchingRule { PayeePattern = "Amazon", Category = "Shopping", TenantId = _tenant1.Id },
            new PayeeMatchingRule { PayeePattern = "Starbucks", Category = "Coffee", TenantId = _tenant1.Id },
            new PayeeMatchingRule { PayeePattern = "Target", Category = "Shopping", TenantId = _tenant2.Id }
        );
        await _context.SaveChangesAsync();

        // When: Querying for tenant 1's rules
        var tenant1Rules = await _context.PayeeMatchingRules
            .Where(r => r.TenantId == _tenant1.Id)
            .ToListAsync();

        // Then: Should only return rules for tenant 1
        Assert.That(tenant1Rules, Has.Count.EqualTo(2));
        Assert.That(tenant1Rules.All(r => r.TenantId == _tenant1.Id), Is.True);
    }

    [Test]
    public async Task PayeeMatchingRule_TenantsAreIsolated()
    {
        // Given: Rules for different tenants
        var tenant1Rule = new PayeeMatchingRule
        {
            PayeePattern = "Tenant 1 Pattern",
            Category = "Tenant 1 Category",
            TenantId = _tenant1.Id
        };
        var tenant2Rule = new PayeeMatchingRule
        {
            PayeePattern = "Tenant 2 Pattern",
            Category = "Tenant 2 Category",
            TenantId = _tenant2.Id
        };

        _context.PayeeMatchingRules.AddRange(tenant1Rule, tenant2Rule);
        await _context.SaveChangesAsync();

        // When: Querying each tenant's rules
        var tenant1Rules = await _context.PayeeMatchingRules
            .Where(r => r.TenantId == _tenant1.Id)
            .ToListAsync();
        var tenant2Rules = await _context.PayeeMatchingRules
            .Where(r => r.TenantId == _tenant2.Id)
            .ToListAsync();

        // Then: Each tenant should only see their own rules
        Assert.That(tenant1Rules, Has.Count.EqualTo(1));
        Assert.That(tenant2Rules, Has.Count.EqualTo(1));
        Assert.That(tenant1Rules[0].PayeePattern, Is.EqualTo("Tenant 1 Pattern"));
        Assert.That(tenant2Rules[0].PayeePattern, Is.EqualTo("Tenant 2 Pattern"));
    }

    [Test]
    public async Task PayeeMatchingRule_CanBeUpdated()
    {
        // Given: An existing rule
        var rule = new PayeeMatchingRule
        {
            PayeePattern = "Original Pattern",
            Category = "Original Category",
            TenantId = _tenant1.Id
        };
        _context.PayeeMatchingRules.Add(rule);
        await _context.SaveChangesAsync();
        var id = rule.Id;
        var originalModifiedAt = rule.ModifiedAt;

        // When: Updating the rule
        await Task.Delay(10); // Ensure timestamp difference
        rule.PayeePattern = "Updated Pattern";
        rule.Category = "Updated Category";
        rule.ModifiedAt = DateTimeOffset.UtcNow;
        await _context.SaveChangesAsync();

        // Then: Changes should be persisted
        var updated = await _context.PayeeMatchingRules.FindAsync(id);
        Assert.That(updated, Is.Not.Null);
        Assert.That(updated!.PayeePattern, Is.EqualTo("Updated Pattern"));
        Assert.That(updated.Category, Is.EqualTo("Updated Category"));
        Assert.That(updated.ModifiedAt, Is.GreaterThan(originalModifiedAt));
    }

    [Test]
    public async Task PayeeMatchingRule_CanBeDeleted()
    {
        // Given: An existing rule
        var rule = new PayeeMatchingRule
        {
            PayeePattern = "Test Pattern",
            Category = "Test Category",
            TenantId = _tenant1.Id
        };
        _context.PayeeMatchingRules.Add(rule);
        await _context.SaveChangesAsync();
        var id = rule.Id;

        // When: Deleting the rule
        _context.PayeeMatchingRules.Remove(rule);
        await _context.SaveChangesAsync();

        // Then: Rule should be removed from database
        var deleted = await _context.PayeeMatchingRules.FindAsync(id);
        Assert.That(deleted, Is.Null);
    }

    [Test]
    public async Task PayeeMatchingRule_CanQueryByKey()
    {
        // Given: A rule with a generated key
        var rule = new PayeeMatchingRule
        {
            PayeePattern = "Amazon",
            Category = "Shopping",
            TenantId = _tenant1.Id
        };
        _context.PayeeMatchingRules.Add(rule);
        await _context.SaveChangesAsync();
        var key = rule.Key;

        // When: Querying by Key
        var found = await _context.PayeeMatchingRules
            .FirstOrDefaultAsync(r => r.Key == key);

        // Then: Should find the rule
        Assert.That(found, Is.Not.Null);
        Assert.That(found!.PayeePattern, Is.EqualTo("Amazon"));
        Assert.That(found.Key, Is.EqualTo(key));
    }

    [Test]
    public async Task PayeeMatchingRule_NavigationPropertyToTenant()
    {
        // Given: A rule with tenant navigation property
        var rule = new PayeeMatchingRule
        {
            PayeePattern = "Starbucks",
            Category = "Coffee",
            TenantId = _tenant1.Id
        };
        _context.PayeeMatchingRules.Add(rule);
        await _context.SaveChangesAsync();

        // When: Loading rule with tenant navigation property
        var retrieved = await _context.PayeeMatchingRules
            .Include(r => r.Tenant)
            .FirstAsync(r => r.Id == rule.Id);

        // Then: Navigation property should be populated
        Assert.That(retrieved.Tenant, Is.Not.Null);
        Assert.That(retrieved.Tenant!.Id, Is.EqualTo(_tenant1.Id));
        Assert.That(retrieved.Tenant.Name, Is.EqualTo(_tenant1.Name));
    }

    [Test]
    public async Task PayeeMatchingRule_KeyIsUniqueAcrossAllTenants()
    {
        // Given: Rules from different tenants
        var rule1 = new PayeeMatchingRule
        {
            PayeePattern = "Tenant 1 Pattern",
            Category = "Category 1",
            TenantId = _tenant1.Id
        };
        var rule2 = new PayeeMatchingRule
        {
            PayeePattern = "Tenant 2 Pattern",
            Category = "Category 2",
            TenantId = _tenant2.Id
        };

        _context.PayeeMatchingRules.AddRange(rule1, rule2);
        await _context.SaveChangesAsync();

        // When: Checking the keys
        var allKeys = await _context.PayeeMatchingRules
            .Select(r => r.Key)
            .ToListAsync();

        // Then: All keys should be unique
        Assert.That(allKeys, Is.Unique);
        Assert.That(allKeys, Has.Count.EqualTo(2));
    }

    [Test]
    public async Task PayeeMatchingRule_PayeePatternIsRequired()
    {
        // Given: A rule with null PayeePattern
        var rule = new PayeeMatchingRule
        {
            PayeePattern = null!, // Violates required constraint
            Category = "Test Category",
            TenantId = _tenant1.Id
        };

        _context.PayeeMatchingRules.Add(rule);

        // When/Then: Saving should fail with constraint violation
        Assert.ThrowsAsync<DbUpdateException>(async () => await _context.SaveChangesAsync());
    }

    [Test]
    public async Task PayeeMatchingRule_CategoryIsRequired()
    {
        // Given: A rule with null Category
        var rule = new PayeeMatchingRule
        {
            PayeePattern = "Test Pattern",
            Category = null!, // Violates required constraint
            TenantId = _tenant1.Id
        };

        _context.PayeeMatchingRules.Add(rule);

        // When/Then: Saving should fail with constraint violation
        Assert.ThrowsAsync<DbUpdateException>(async () => await _context.SaveChangesAsync());
    }

    [Test]
    public async Task PayeeMatchingRule_PayeePatternMaxLengthIs200()
    {
        // Given: A rule with PayeePattern exactly at max length (200 chars)
        var pattern200 = new string('A', 200);
        var rule = new PayeeMatchingRule
        {
            PayeePattern = pattern200,
            Category = "Test Category",
            TenantId = _tenant1.Id
        };

        // When: Saving the rule
        _context.PayeeMatchingRules.Add(rule);
        await _context.SaveChangesAsync();

        // Then: PayeePattern should be saved without truncation
        var retrieved = await _context.PayeeMatchingRules.FindAsync(rule.Id);
        Assert.That(retrieved, Is.Not.Null);
        Assert.That(retrieved!.PayeePattern, Is.EqualTo(pattern200));
        Assert.That(retrieved.PayeePattern.Length, Is.EqualTo(200));
    }

    [Test]
    public async Task PayeeMatchingRule_CategoryMaxLengthIs200()
    {
        // Given: A rule with Category exactly at max length (200 chars)
        var category200 = new string('B', 200);
        var rule = new PayeeMatchingRule
        {
            PayeePattern = "Test Pattern",
            Category = category200,
            TenantId = _tenant1.Id
        };

        // When: Saving the rule
        _context.PayeeMatchingRules.Add(rule);
        await _context.SaveChangesAsync();

        // Then: Category should be saved without truncation
        var retrieved = await _context.PayeeMatchingRules.FindAsync(rule.Id);
        Assert.That(retrieved, Is.Not.Null);
        Assert.That(retrieved!.Category, Is.EqualTo(category200));
        Assert.That(retrieved.Category.Length, Is.EqualTo(200));
    }

    [Test]
    public async Task PayeeMatchingRule_PayeeIsRegexDefaultsToFalse()
    {
        // Given: A rule without explicitly setting PayeeIsRegex
        var rule = new PayeeMatchingRule
        {
            PayeePattern = "Amazon",
            Category = "Shopping",
            TenantId = _tenant1.Id
            // PayeeIsRegex not set
        };

        // When: Saving the rule
        _context.PayeeMatchingRules.Add(rule);
        await _context.SaveChangesAsync();

        // Then: PayeeIsRegex should default to false
        var retrieved = await _context.PayeeMatchingRules.FindAsync(rule.Id);
        Assert.That(retrieved, Is.Not.Null);
        Assert.That(retrieved!.PayeeIsRegex, Is.False);
    }

    [Test]
    public async Task PayeeMatchingRule_PayeeIsRegexCanBeSetToTrue()
    {
        // Given: A rule with PayeeIsRegex set to true
        var rule = new PayeeMatchingRule
        {
            PayeePattern = "^AMZN.*",
            PayeeIsRegex = true,
            Category = "Shopping",
            TenantId = _tenant1.Id
        };

        // When: Saving the rule
        _context.PayeeMatchingRules.Add(rule);
        await _context.SaveChangesAsync();

        // Then: PayeeIsRegex should be persisted as true
        var retrieved = await _context.PayeeMatchingRules.FindAsync(rule.Id);
        Assert.That(retrieved, Is.Not.Null);
        Assert.That(retrieved!.PayeeIsRegex, Is.True);
    }

    [Test]
    public async Task PayeeMatchingRule_CreatedAtIsSetAutomatically()
    {
        // Given: A rule without explicitly setting CreatedAt
        var beforeCreation = DateTimeOffset.UtcNow;
        var rule = new PayeeMatchingRule
        {
            PayeePattern = "Starbucks",
            Category = "Coffee",
            TenantId = _tenant1.Id
        };
        var afterCreation = DateTimeOffset.UtcNow;

        // When: Saving the rule
        _context.PayeeMatchingRules.Add(rule);
        await _context.SaveChangesAsync();

        // Then: CreatedAt should be set to current time
        var retrieved = await _context.PayeeMatchingRules.FindAsync(rule.Id);
        Assert.That(retrieved, Is.Not.Null);
        Assert.That(retrieved!.CreatedAt, Is.GreaterThanOrEqualTo(beforeCreation));
        Assert.That(retrieved.CreatedAt, Is.LessThanOrEqualTo(afterCreation.AddSeconds(1)));
    }

    [Test]
    public async Task PayeeMatchingRule_ModifiedAtIsSetAutomatically()
    {
        // Given: A rule without explicitly setting ModifiedAt
        var beforeCreation = DateTimeOffset.UtcNow;
        var rule = new PayeeMatchingRule
        {
            PayeePattern = "Target",
            Category = "Shopping",
            TenantId = _tenant1.Id
        };
        var afterCreation = DateTimeOffset.UtcNow;

        // When: Saving the rule
        _context.PayeeMatchingRules.Add(rule);
        await _context.SaveChangesAsync();

        // Then: ModifiedAt should be set to current time
        var retrieved = await _context.PayeeMatchingRules.FindAsync(rule.Id);
        Assert.That(retrieved, Is.Not.Null);
        Assert.That(retrieved!.ModifiedAt, Is.GreaterThanOrEqualTo(beforeCreation));
        Assert.That(retrieved.ModifiedAt, Is.LessThanOrEqualTo(afterCreation.AddSeconds(1)));
    }

    [Test]
    public async Task PayeeMatchingRule_LastUsedAtDefaultsToNull()
    {
        // Given: A newly created rule
        var rule = new PayeeMatchingRule
        {
            PayeePattern = "Costco",
            Category = "Groceries",
            TenantId = _tenant1.Id
        };

        // When: Saving the rule
        _context.PayeeMatchingRules.Add(rule);
        await _context.SaveChangesAsync();

        // Then: LastUsedAt should be null (rule hasn't been used yet)
        var retrieved = await _context.PayeeMatchingRules.FindAsync(rule.Id);
        Assert.That(retrieved, Is.Not.Null);
        Assert.That(retrieved!.LastUsedAt, Is.Null);
    }

    [Test]
    public async Task PayeeMatchingRule_LastUsedAtCanBeSet()
    {
        // Given: A rule with LastUsedAt explicitly set
        var usedTime = DateTimeOffset.UtcNow;
        var rule = new PayeeMatchingRule
        {
            PayeePattern = "Safeway",
            Category = "Groceries",
            LastUsedAt = usedTime,
            TenantId = _tenant1.Id
        };

        // When: Saving the rule
        _context.PayeeMatchingRules.Add(rule);
        await _context.SaveChangesAsync();

        // Then: LastUsedAt should be persisted
        var retrieved = await _context.PayeeMatchingRules.FindAsync(rule.Id);
        Assert.That(retrieved, Is.Not.Null);
        Assert.That(retrieved!.LastUsedAt, Is.Not.Null);
        // Allow small tolerance for DateTimeOffset precision
        Assert.That(retrieved.LastUsedAt!.Value, Is.EqualTo(usedTime).Within(TimeSpan.FromSeconds(1)));
    }

    [Test]
    public async Task PayeeMatchingRule_MatchCountDefaultsToZero()
    {
        // Given: A newly created rule without setting MatchCount
        var rule = new PayeeMatchingRule
        {
            PayeePattern = "Walmart",
            Category = "Shopping",
            TenantId = _tenant1.Id
        };

        // When: Saving the rule
        _context.PayeeMatchingRules.Add(rule);
        await _context.SaveChangesAsync();

        // Then: MatchCount should default to 0
        var retrieved = await _context.PayeeMatchingRules.FindAsync(rule.Id);
        Assert.That(retrieved, Is.Not.Null);
        Assert.That(retrieved!.MatchCount, Is.EqualTo(0));
    }

    [Test]
    public async Task PayeeMatchingRule_MatchCountCanBeUpdated()
    {
        // Given: An existing rule
        var rule = new PayeeMatchingRule
        {
            PayeePattern = "McDonald's",
            Category = "Dining",
            TenantId = _tenant1.Id
        };
        _context.PayeeMatchingRules.Add(rule);
        await _context.SaveChangesAsync();

        // When: Incrementing MatchCount
        rule.MatchCount = 5;
        await _context.SaveChangesAsync();

        // Then: MatchCount should be updated
        var retrieved = await _context.PayeeMatchingRules.FindAsync(rule.Id);
        Assert.That(retrieved, Is.Not.Null);
        Assert.That(retrieved!.MatchCount, Is.EqualTo(5));
    }

    [Test]
    public async Task PayeeMatchingRule_DateTimeOffsetStoredAsISO8601Text()
    {
        // Given: A rule with specific DateTimeOffset values
        var createdAt = new DateTimeOffset(2024, 1, 15, 10, 30, 0, TimeSpan.Zero);
        var modifiedAt = new DateTimeOffset(2024, 1, 20, 14, 45, 0, TimeSpan.Zero);
        var rule = new PayeeMatchingRule
        {
            PayeePattern = "Test Pattern",
            Category = "Test Category",
            CreatedAt = createdAt,
            ModifiedAt = modifiedAt,
            TenantId = _tenant1.Id
        };

        _context.PayeeMatchingRules.Add(rule);
        await _context.SaveChangesAsync();

        // When: Checking the raw database value
        var connection = _context.Database.GetDbConnection();
        await connection.OpenAsync();
        using var command = connection.CreateCommand();
        command.CommandText = $"SELECT CreatedAt, ModifiedAt FROM \"YoFi.V3.PayeeMatchingRules\" WHERE Id = {rule.Id}";
        using var reader = await command.ExecuteReaderAsync();
        await reader.ReadAsync();
        var createdAtText = reader.GetString(0);
        var modifiedAtText = reader.GetString(1);

        // Then: DateTimeOffset should be stored as ISO 8601 text
        Assert.That(createdAtText, Does.Contain("2024-01-15"));
        Assert.That(modifiedAtText, Does.Contain("2024-01-20"));

        // And: Values should round-trip correctly
        var retrieved = await _context.PayeeMatchingRules.FindAsync(rule.Id);
        Assert.That(retrieved!.CreatedAt, Is.EqualTo(createdAt));
        Assert.That(retrieved.ModifiedAt, Is.EqualTo(modifiedAt));
    }

    [Test]
    public async Task PayeeMatchingRule_SupportsOrderingByModifiedAt()
    {
        // Given: Rules with different modified dates
        var date1 = DateTimeOffset.UtcNow.AddDays(-5);
        var date2 = DateTimeOffset.UtcNow.AddDays(-3);
        var date3 = DateTimeOffset.UtcNow;

        _context.PayeeMatchingRules.AddRange(
            new PayeeMatchingRule { PayeePattern = "Old", Category = "Cat1", ModifiedAt = date1, TenantId = _tenant1.Id },
            new PayeeMatchingRule { PayeePattern = "Mid", Category = "Cat2", ModifiedAt = date2, TenantId = _tenant1.Id },
            new PayeeMatchingRule { PayeePattern = "New", Category = "Cat3", ModifiedAt = date3, TenantId = _tenant1.Id }
        );
        await _context.SaveChangesAsync();

        // When: Querying with ordering by ModifiedAt descending
        var results = await _context.PayeeMatchingRules
            .Where(r => r.TenantId == _tenant1.Id)
            .OrderByDescending(r => r.ModifiedAt)
            .ToListAsync();

        // Then: Should return rules in descending modified date order
        Assert.That(results, Has.Count.EqualTo(3));
        Assert.That(results[0].PayeePattern, Is.EqualTo("New"));
        Assert.That(results[1].PayeePattern, Is.EqualTo("Mid"));
        Assert.That(results[2].PayeePattern, Is.EqualTo("Old"));
    }

    [Test]
    public async Task PayeeMatchingRule_CanFilterByPayeeIsRegex()
    {
        // Given: Rules with both substring and regex patterns
        _context.PayeeMatchingRules.AddRange(
            new PayeeMatchingRule { PayeePattern = "Amazon", PayeeIsRegex = false, Category = "Shopping", TenantId = _tenant1.Id },
            new PayeeMatchingRule { PayeePattern = "^AMZN.*", PayeeIsRegex = true, Category = "Shopping", TenantId = _tenant1.Id },
            new PayeeMatchingRule { PayeePattern = "Starbucks", PayeeIsRegex = false, Category = "Coffee", TenantId = _tenant1.Id }
        );
        await _context.SaveChangesAsync();

        // When: Querying for regex rules only
        var regexRules = await _context.PayeeMatchingRules
            .Where(r => r.TenantId == _tenant1.Id && r.PayeeIsRegex)
            .ToListAsync();

        // Then: Should return only regex rules
        Assert.That(regexRules, Has.Count.EqualTo(1));
        Assert.That(regexRules[0].PayeePattern, Is.EqualTo("^AMZN.*"));
    }

    [Test]
    public async Task PayeeMatchingRule_CascadeDeleteWithTenant()
    {
        // Given: Rules belonging to a tenant
        _context.PayeeMatchingRules.AddRange(
            new PayeeMatchingRule { PayeePattern = "Pattern1", Category = "Cat1", TenantId = _tenant1.Id },
            new PayeeMatchingRule { PayeePattern = "Pattern2", Category = "Cat2", TenantId = _tenant1.Id }
        );
        await _context.SaveChangesAsync();

        var ruleCount = await _context.PayeeMatchingRules.CountAsync(r => r.TenantId == _tenant1.Id);
        Assert.That(ruleCount, Is.EqualTo(2));

        // When: Deleting the tenant
        _context.Tenants.Remove(_tenant1);
        await _context.SaveChangesAsync();

        // Then: Rules should be cascade deleted
        var remainingRules = await _context.PayeeMatchingRules
            .Where(r => r.TenantId == _tenant1.Id)
            .ToListAsync();
        Assert.That(remainingRules, Is.Empty);
    }

    [Test]
    public async Task PayeeMatchingRule_IndexOnTenantIdExists()
    {
        // Given: Database with PayeeMatchingRules table

        // When: Checking for the TenantId index
        var connection = _context.Database.GetDbConnection();
        await connection.OpenAsync();
        using var command = connection.CreateCommand();
        command.CommandText = @"
            SELECT name FROM sqlite_master
            WHERE type='index'
            AND tbl_name='YoFi.V3.PayeeMatchingRules'
            AND sql LIKE '%TenantId%'";
        var indexName = await command.ExecuteScalarAsync();

        // Then: TenantId index should exist
        Assert.That(indexName, Is.Not.Null);
    }

    [Test]
    public async Task PayeeMatchingRule_UniqueKeyIndexExists()
    {
        // Given: Database with PayeeMatchingRules table

        // When: Checking for the unique Key index
        var connection = _context.Database.GetDbConnection();
        await connection.OpenAsync();
        using var command = connection.CreateCommand();
        command.CommandText = @"
            SELECT name FROM sqlite_master
            WHERE type='index'
            AND tbl_name='YoFi.V3.PayeeMatchingRules'
            AND sql LIKE '%Key%'
            AND sql LIKE '%UNIQUE%'";
        var indexName = await command.ExecuteScalarAsync();

        // Then: Unique Key index should exist
        Assert.That(indexName, Is.Not.Null);
    }

    [Test]
    public async Task PayeeMatchingRule_SupportsSearchByPayeePattern()
    {
        // Given: Multiple rules with different patterns
        _context.PayeeMatchingRules.AddRange(
            new PayeeMatchingRule { PayeePattern = "Amazon Prime", Category = "Subscription", TenantId = _tenant1.Id },
            new PayeeMatchingRule { PayeePattern = "Amazon.com", Category = "Shopping", TenantId = _tenant1.Id },
            new PayeeMatchingRule { PayeePattern = "Starbucks", Category = "Coffee", TenantId = _tenant1.Id }
        );
        await _context.SaveChangesAsync();

        // When: Searching for rules containing "Amazon"
        var searchResults = await _context.PayeeMatchingRules
            .Where(r => r.TenantId == _tenant1.Id && r.PayeePattern.Contains("Amazon"))
            .ToListAsync();

        // Then: Should return matching rules
        Assert.That(searchResults, Has.Count.EqualTo(2));
        Assert.That(searchResults.All(r => r.PayeePattern.Contains("Amazon")), Is.True);
    }

    [Test]
    public async Task PayeeMatchingRule_SupportsSearchByCategory()
    {
        // Given: Multiple rules with different categories
        _context.PayeeMatchingRules.AddRange(
            new PayeeMatchingRule { PayeePattern = "Safeway", Category = "Groceries", TenantId = _tenant1.Id },
            new PayeeMatchingRule { PayeePattern = "Costco", Category = "Groceries", TenantId = _tenant1.Id },
            new PayeeMatchingRule { PayeePattern = "Shell", Category = "Gas", TenantId = _tenant1.Id }
        );
        await _context.SaveChangesAsync();

        // When: Searching for rules with "Groceries" category
        var groceryRules = await _context.PayeeMatchingRules
            .Where(r => r.TenantId == _tenant1.Id && r.Category == "Groceries")
            .ToListAsync();

        // Then: Should return matching rules
        Assert.That(groceryRules, Has.Count.EqualTo(2));
        Assert.That(groceryRules.All(r => r.Category == "Groceries"), Is.True);
    }
}
