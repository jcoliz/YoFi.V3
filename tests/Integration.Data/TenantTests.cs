using Microsoft.EntityFrameworkCore;
using YoFi.V3.Data;
using YoFi.V3.Entities.Tenancy.Models;

namespace YoFi.V3.Tests.Integration.Data;

/// <summary>
/// Integration tests for Tenant entity and related database operations.
/// These tests verify database configuration, constraints, and entity relationships.
/// </summary>
public class TenantTests
{
    private ApplicationDbContext _context;
    private DbContextOptions<ApplicationDbContext> _options;

    [SetUp]
    public void Setup()
    {
        // Use in-memory database for testing
        _options = new DbContextOptionsBuilder<ApplicationDbContext>()
            .UseSqlite("DataSource=:memory:")
            .Options;

        _context = new ApplicationDbContext(_options);
        _context.Database.OpenConnection(); // Keep in-memory DB alive
        _context.Database.EnsureCreated();
    }

    [TearDown]
    public void TearDown()
    {
        _context.Database.CloseConnection();
        _context.Dispose();
    }

    [Test]
    public async Task Tenant_HasCorrectTableName()
    {
        // Given: A tenant
        var tenant = new Tenant
        {
            Name = "Test Tenant",
            Description = "A test tenant"
        };

        _context.Tenants.Add(tenant);
        await _context.SaveChangesAsync();

        // When: Checking the table name in the database
        var connection = _context.Database.GetDbConnection();
        await connection.OpenAsync();
        using var command = connection.CreateCommand();
        command.CommandText = "SELECT name FROM sqlite_master WHERE type='table' AND name='YoFi.V3.Tenants'";
        var tableName = await command.ExecuteScalarAsync();

        // Then: The table should exist with the correct name
        Assert.That(tableName, Is.EqualTo("YoFi.V3.Tenants"));
    }

    [Test]
    public async Task Tenant_IdAndKeyAreAutoGenerated()
    {
        // Given: A tenant without Id explicitly set
        var tenant = new Tenant
        {
            Name = "Test Tenant",
            Description = "A test tenant"
        };

        Assert.That(tenant.Id, Is.EqualTo(0)); // Initially zero
        var initialKey = tenant.Key;
        Assert.That(initialKey, Is.Not.EqualTo(Guid.Empty)); // Key is auto-generated on construction

        // When: Adding and saving the tenant
        _context.Tenants.Add(tenant);
        await _context.SaveChangesAsync();

        // Then: Id should be auto-generated, Key should remain the same
        Assert.That(tenant.Id, Is.GreaterThan(0));
        Assert.That(tenant.Key, Is.EqualTo(initialKey));
    }

    [Test]
    public async Task Tenant_NameCanBeEmpty()
    {
        // Given: A tenant with an empty name (allowed at DB level)
        var tenant = new Tenant
        {
            Name = string.Empty,
            Description = "A test tenant"
        };

        _context.Tenants.Add(tenant);

        // When: Saving the tenant
        await _context.SaveChangesAsync();

        // Then: Should be saved successfully (validation should happen at application level)
        Assert.That(tenant.Id, Is.GreaterThan(0));
    }

    [Test]
    public async Task Tenant_NameMaxLengthConfigured()
    {
        // Given: A tenant with a name exceeding the configured max length (100 chars)
        var longName = new string('A', 101);
        var tenant = new Tenant
        {
            Name = longName,
            Description = "A test tenant"
        };

        _context.Tenants.Add(tenant);
        await _context.SaveChangesAsync();

        // When: Retrieving the tenant
        var retrieved = await _context.Tenants.FindAsync(tenant.Id);

        // Then: SQLite doesn't enforce max length by default, but the configuration exists
        // Application-level validation should prevent this scenario
        Assert.That(retrieved, Is.Not.Null);
        Assert.That(retrieved!.Name, Is.EqualTo(longName));
    }

    [Test]
    public async Task Tenant_DescriptionCanBeEmpty()
    {
        // Given: A tenant with an empty description (allowed at DB level)
        var tenant = new Tenant
        {
            Name = "Test Tenant",
            Description = string.Empty
        };

        _context.Tenants.Add(tenant);

        // When: Saving the tenant
        await _context.SaveChangesAsync();

        // Then: Should be saved successfully (validation should happen at application level)
        Assert.That(tenant.Id, Is.GreaterThan(0));
    }

    [Test]
    public async Task Tenant_DescriptionMaxLengthConfigured()
    {
        // Given: A tenant with a description exceeding the configured max length (500 chars)
        var longDescription = new string('A', 501);
        var tenant = new Tenant
        {
            Name = "Test Tenant",
            Description = longDescription
        };

        _context.Tenants.Add(tenant);
        await _context.SaveChangesAsync();

        // When: Retrieving the tenant
        var retrieved = await _context.Tenants.FindAsync(tenant.Id);

        // Then: SQLite doesn't enforce max length by default, but the configuration exists
        // Application-level validation should prevent this scenario
        Assert.That(retrieved, Is.Not.Null);
        Assert.That(retrieved!.Description, Is.EqualTo(longDescription));
    }

    [Test]
    public async Task Tenant_CreatedAtIsAutoSet()
    {
        // Given: A tenant
        var beforeCreate = DateTimeOffset.UtcNow.AddSeconds(-1);
        var tenant = new Tenant
        {
            Name = "Test Tenant",
            Description = "A test tenant"
        };
        var afterCreate = DateTimeOffset.UtcNow.AddSeconds(1);

        // When: Creating the tenant
        _context.Tenants.Add(tenant);
        await _context.SaveChangesAsync();

        // Then: CreatedAt should be set to approximately now
        Assert.That(tenant.CreatedAt, Is.GreaterThan(beforeCreate));
        Assert.That(tenant.CreatedAt, Is.LessThan(afterCreate));
    }

    [Test]
    public async Task Tenant_KeyIsUnique()
    {
        // Given: Two tenants
        var tenant1 = new Tenant
        {
            Name = "Tenant 1",
            Description = "First tenant"
        };
        var tenant2 = new Tenant
        {
            Name = "Tenant 2",
            Description = "Second tenant"
        };

        _context.Tenants.AddRange(tenant1, tenant2);
        await _context.SaveChangesAsync();

        // When: Checking the keys
        // Then: Keys should be unique
        Assert.That(tenant1.Key, Is.Not.EqualTo(tenant2.Key));
    }

    [Test]
    public async Task Tenant_CanBeUpdated()
    {
        // Given: An existing tenant
        var tenant = new Tenant
        {
            Name = "Original Name",
            Description = "Original Description"
        };
        _context.Tenants.Add(tenant);
        await _context.SaveChangesAsync();
        var id = tenant.Id;

        // When: Updating the tenant
        tenant.Name = "Updated Name";
        tenant.Description = "Updated Description";
        await _context.SaveChangesAsync();

        // Then: Changes should be persisted
        var updated = await _context.Tenants.FindAsync(id);
        Assert.That(updated, Is.Not.Null);
        Assert.That(updated!.Name, Is.EqualTo("Updated Name"));
        Assert.That(updated.Description, Is.EqualTo("Updated Description"));
    }

    [Test]
    public async Task Tenant_CanBeDeleted()
    {
        // Given: An existing tenant
        var tenant = new Tenant
        {
            Name = "Test Tenant",
            Description = "A test tenant"
        };
        _context.Tenants.Add(tenant);
        await _context.SaveChangesAsync();
        var id = tenant.Id;

        // When: Deleting the tenant
        _context.Tenants.Remove(tenant);
        await _context.SaveChangesAsync();

        // Then: Tenant should be removed from database
        var deleted = await _context.Tenants.FindAsync(id);
        Assert.That(deleted, Is.Null);
    }

    [Test]
    public async Task Tenant_CanQueryByKey()
    {
        // Given: A tenant with a generated key
        var tenant = new Tenant
        {
            Name = "Test Tenant",
            Description = "A test tenant"
        };
        _context.Tenants.Add(tenant);
        await _context.SaveChangesAsync();
        var key = tenant.Key;

        // When: Querying by Key
        var found = await _context.Tenants
            .FirstOrDefaultAsync(t => t.Key == key);

        // Then: Should find the tenant
        Assert.That(found, Is.Not.Null);
        Assert.That(found!.Name, Is.EqualTo("Test Tenant"));
        Assert.That(found.Key, Is.EqualTo(key));
    }

    [Test]
    public async Task Tenant_RoleAssignmentsNavigationProperty()
    {
        // Given: A tenant with role assignments
        var tenant = new Tenant
        {
            Name = "Test Tenant",
            Description = "A test tenant"
        };
        _context.Tenants.Add(tenant);
        await _context.SaveChangesAsync();

        var roleAssignment = new UserTenantRoleAssignment
        {
            UserId = "user123",
            TenantId = tenant.Id,
            Role = TenantRole.Editor
        };
        _context.UserTenantRoleAssignments.Add(roleAssignment);
        await _context.SaveChangesAsync();

        // When: Loading tenant with role assignments
        var retrieved = await _context.Tenants
            .Include(t => t.RoleAssignments)
            .FirstAsync(t => t.Id == tenant.Id);

        // Then: Navigation property should be populated
        Assert.That(retrieved.RoleAssignments, Is.Not.Null);
        Assert.That(retrieved.RoleAssignments, Has.Count.EqualTo(1));
        Assert.That(retrieved.RoleAssignments.First().UserId, Is.EqualTo("user123"));
    }

    [Test]
    public async Task Tenant_DeletingTenantCascadesRoleAssignments()
    {
        // Given: A tenant with role assignments
        var tenant = new Tenant
        {
            Name = "Test Tenant",
            Description = "A test tenant"
        };
        _context.Tenants.Add(tenant);
        await _context.SaveChangesAsync();

        var roleAssignment = new UserTenantRoleAssignment
        {
            UserId = "user123",
            TenantId = tenant.Id,
            Role = TenantRole.Editor
        };
        _context.UserTenantRoleAssignments.Add(roleAssignment);
        await _context.SaveChangesAsync();
        var roleAssignmentId = roleAssignment.Id;

        // When: Deleting the tenant
        _context.Tenants.Remove(tenant);
        await _context.SaveChangesAsync();

        // Then: Role assignments should be cascade deleted
        var deletedRoleAssignment = await _context.UserTenantRoleAssignments.FindAsync(roleAssignmentId);
        Assert.That(deletedRoleAssignment, Is.Null);
    }

    [Test]
    public async Task Tenant_SupportsMultipleTenants()
    {
        // Given: Multiple tenants
        var tenants = new[]
        {
            new Tenant { Name = "Tenant 1", Description = "First tenant" },
            new Tenant { Name = "Tenant 2", Description = "Second tenant" },
            new Tenant { Name = "Tenant 3", Description = "Third tenant" }
        };

        _context.Tenants.AddRange(tenants);
        await _context.SaveChangesAsync();

        // When: Querying all tenants
        var allTenants = await _context.Tenants.ToListAsync();

        // Then: Should retrieve all tenants
        Assert.That(allTenants, Has.Count.EqualTo(3));
    }
}
