using Microsoft.EntityFrameworkCore;
using YoFi.V3.Data;
using YoFi.V3.Entities.Models;
using YoFi.V3.Entities.Tenancy.Models;

namespace YoFi.V3.Tests.Integration.Data;

/// <summary>
/// Integration tests for ImportReviewTransaction entity and tenant-scoped data operations.
/// These tests verify database behavior, tenant isolation, EF Core configuration, and duplicate detection metadata.
/// </summary>
public class ImportReviewTransactionTests
{
    private ApplicationDbContext _context = null!;
    private DbContextOptions<ApplicationDbContext> _options = null!;
    private Tenant _tenant1 = null!;
    private Tenant _tenant2 = null!;

    [SetUp]
    public async Task Setup()
    {
        // Use in-memory database for testing
        _options = new DbContextOptionsBuilder<ApplicationDbContext>()
            .UseSqlite("DataSource=:memory:")
            .Options;

        _context = new ApplicationDbContext(_options);
        _context.Database.OpenConnection(); // Keep in-memory DB alive
        _context.Database.EnsureCreated();

        // Create test tenants
        _tenant1 = new Tenant { Name = "Tenant 1", Description = "First test tenant" };
        _tenant2 = new Tenant { Name = "Tenant 2", Description = "Second test tenant" };
        _context.Tenants.AddRange(_tenant1, _tenant2);
        await _context.SaveChangesAsync();
    }

    [TearDown]
    public void TearDown()
    {
        _context.Database.CloseConnection();
        _context.Dispose();
    }

    [Test]
    public async Task ImportReviewTransaction_HasCorrectTableName()
    {
        // Given: An import review transaction
        var transaction = new ImportReviewTransaction
        {
            Date = DateOnly.FromDateTime(DateTime.Now),
            Payee = "Test Payee",
            Amount = 100.00m,
            TenantId = _tenant1.Id
        };

        _context.ImportReviewTransactions.Add(transaction);
        await _context.SaveChangesAsync();

        // When: Checking the table name in the database
        var connection = _context.Database.GetDbConnection();
        await connection.OpenAsync();
        using var command = connection.CreateCommand();
        command.CommandText = "SELECT name FROM sqlite_master WHERE type='table' AND name='YoFi.V3.ImportReviewTransactions'";
        var tableName = await command.ExecuteScalarAsync();

        // Then: The table should exist with the correct name
        Assert.That(tableName, Is.EqualTo("YoFi.V3.ImportReviewTransactions"));
    }

    [Test]
    public async Task ImportReviewTransaction_IdIsAutoGenerated_KeyIsPreset()
    {
        // Given: An import review transaction without Id explicitly set
        var transaction = new ImportReviewTransaction
        {
            Date = DateOnly.FromDateTime(DateTime.Now),
            Payee = "Test Payee",
            Amount = 100.00m,
            TenantId = _tenant1.Id
        };

        Assert.That(transaction.Id, Is.EqualTo(0)); // Initially zero
        var initialKey = transaction.Key;
        Assert.That(initialKey, Is.Not.EqualTo(Guid.Empty)); // Key is auto-generated on construction

        // When: Adding and saving the transaction
        _context.ImportReviewTransactions.Add(transaction);
        await _context.SaveChangesAsync();

        // Then: Id should be auto-generated, Key should remain the same
        Assert.That(transaction.Id, Is.GreaterThan(0));
        Assert.That(transaction.Key, Is.EqualTo(initialKey)); // Key doesn't change
        Assert.That(transaction.Key, Is.Not.EqualTo(Guid.Empty));
    }

    [Test]
    public async Task ImportReviewTransaction_TenantIdIsRequired()
    {
        // Given: An import review transaction without a TenantId (0 is invalid for foreign key)
        var transaction = new ImportReviewTransaction
        {
            Date = DateOnly.FromDateTime(DateTime.Now),
            Payee = "Test Payee",
            Amount = 100.00m,
            TenantId = 0 // Invalid
        };

        _context.ImportReviewTransactions.Add(transaction);

        // When/Then: Saving should fail with a database constraint error
        Assert.ThrowsAsync<DbUpdateException>(async () => await _context.SaveChangesAsync());
    }

    [Test]
    public async Task ImportReviewTransaction_TenantIdForeignKeyConstraint()
    {
        // Given: An import review transaction with a non-existent TenantId
        var transaction = new ImportReviewTransaction
        {
            Date = DateOnly.FromDateTime(DateTime.Now),
            Payee = "Test Payee",
            Amount = 100.00m,
            TenantId = 999999 // Non-existent tenant
        };

        _context.ImportReviewTransactions.Add(transaction);

        // When/Then: Saving should fail due to foreign key constraint
        Assert.ThrowsAsync<DbUpdateException>(async () => await _context.SaveChangesAsync());
    }

    [Test]
    public async Task ImportReviewTransaction_CanQueryByTenantId()
    {
        // Given: Import review transactions for multiple tenants
        _context.ImportReviewTransactions.AddRange(
            new ImportReviewTransaction { Date = DateOnly.FromDateTime(DateTime.Now), Payee = "Payee 1", Amount = 100m, TenantId = _tenant1.Id },
            new ImportReviewTransaction { Date = DateOnly.FromDateTime(DateTime.Now), Payee = "Payee 2", Amount = 200m, TenantId = _tenant1.Id },
            new ImportReviewTransaction { Date = DateOnly.FromDateTime(DateTime.Now), Payee = "Payee 3", Amount = 300m, TenantId = _tenant2.Id }
        );
        await _context.SaveChangesAsync();

        // When: Querying for tenant 1's import review transactions
        var tenant1Transactions = await _context.ImportReviewTransactions
            .Where(t => t.TenantId == _tenant1.Id)
            .ToListAsync();

        // Then: Should only return transactions for tenant 1
        Assert.That(tenant1Transactions, Has.Count.EqualTo(2));
        Assert.That(tenant1Transactions.All(t => t.TenantId == _tenant1.Id), Is.True);
    }

    [Test]
    public async Task ImportReviewTransaction_TenantsAreIsolated()
    {
        // Given: Import review transactions for different tenants
        var tenant1Transaction = new ImportReviewTransaction
        {
            Date = DateOnly.FromDateTime(DateTime.Now),
            Payee = "Tenant 1 Payee",
            Amount = 100m,
            TenantId = _tenant1.Id
        };
        var tenant2Transaction = new ImportReviewTransaction
        {
            Date = DateOnly.FromDateTime(DateTime.Now),
            Payee = "Tenant 2 Payee",
            Amount = 200m,
            TenantId = _tenant2.Id
        };

        _context.ImportReviewTransactions.AddRange(tenant1Transaction, tenant2Transaction);
        await _context.SaveChangesAsync();

        // When: Querying each tenant's import review transactions
        var tenant1Transactions = await _context.ImportReviewTransactions
            .Where(t => t.TenantId == _tenant1.Id)
            .ToListAsync();
        var tenant2Transactions = await _context.ImportReviewTransactions
            .Where(t => t.TenantId == _tenant2.Id)
            .ToListAsync();

        // Then: Each tenant should only see their own transactions
        Assert.That(tenant1Transactions, Has.Count.EqualTo(1));
        Assert.That(tenant2Transactions, Has.Count.EqualTo(1));
        Assert.That(tenant1Transactions[0].Payee, Is.EqualTo("Tenant 1 Payee"));
        Assert.That(tenant2Transactions[0].Payee, Is.EqualTo("Tenant 2 Payee"));
    }

    [Test]
    public async Task ImportReviewTransaction_CanBeDeleted()
    {
        // Given: An existing import review transaction
        var transaction = new ImportReviewTransaction
        {
            Date = DateOnly.FromDateTime(DateTime.Now),
            Payee = "Test Payee",
            Amount = 100m,
            TenantId = _tenant1.Id
        };
        _context.ImportReviewTransactions.Add(transaction);
        await _context.SaveChangesAsync();
        var id = transaction.Id;

        // When: Deleting the transaction
        _context.ImportReviewTransactions.Remove(transaction);
        await _context.SaveChangesAsync();

        // Then: Transaction should be removed from database
        var deleted = await _context.ImportReviewTransactions.FindAsync(id);
        Assert.That(deleted, Is.Null);
    }

    [Test]
    public async Task ImportReviewTransaction_DeletingTenantCascadesDelete()
    {
        // Given: A tenant with import review transactions
        var transaction = new ImportReviewTransaction
        {
            Date = DateOnly.FromDateTime(DateTime.Now),
            Payee = "Test Payee",
            Amount = 100m,
            TenantId = _tenant1.Id
        };
        _context.ImportReviewTransactions.Add(transaction);
        await _context.SaveChangesAsync();
        var transactionId = transaction.Id;

        // When: Deleting the tenant
        _context.Tenants.Remove(_tenant1);
        await _context.SaveChangesAsync();

        // Then: Import review transaction should be cascade deleted
        var deletedTransaction = await _context.ImportReviewTransactions.FindAsync(transactionId);
        Assert.That(deletedTransaction, Is.Null);
    }

    [Test]
    public async Task ImportReviewTransaction_CanQueryByTenantIdAndExternalId()
    {
        // Given: Multiple import review transactions with different ExternalIds
        _context.ImportReviewTransactions.AddRange(
            new ImportReviewTransaction { Date = DateOnly.FromDateTime(DateTime.Now), Payee = "Payee 1", Amount = 100m, ExternalId = "FITID-001", TenantId = _tenant1.Id },
            new ImportReviewTransaction { Date = DateOnly.FromDateTime(DateTime.Now), Payee = "Payee 2", Amount = 200m, ExternalId = "FITID-002", TenantId = _tenant1.Id },
            new ImportReviewTransaction { Date = DateOnly.FromDateTime(DateTime.Now), Payee = "Payee 3", Amount = 300m, ExternalId = "FITID-001", TenantId = _tenant2.Id }
        );
        await _context.SaveChangesAsync();

        // When: Querying by TenantId and ExternalId (duplicate detection pattern)
        var exists = await _context.ImportReviewTransactions
            .AnyAsync(t => t.TenantId == _tenant1.Id && t.ExternalId == "FITID-001");

        // Then: Should find the matching transaction
        Assert.That(exists, Is.True);

        // And: Composite index should make this query efficient
        var transaction = await _context.ImportReviewTransactions
            .FirstOrDefaultAsync(t => t.TenantId == _tenant1.Id && t.ExternalId == "FITID-001");
        Assert.That(transaction, Is.Not.Null);
        Assert.That(transaction!.Payee, Is.EqualTo("Payee 1"));
    }

    [Test]
    public async Task ImportReviewTransaction_CompositeIndexOnTenantIdExternalIdExists()
    {
        // Given: Database with ImportReviewTransactions table

        // When: Checking for the composite index
        var connection = _context.Database.GetDbConnection();
        await connection.OpenAsync();
        using var command = connection.CreateCommand();
        command.CommandText = @"
            SELECT name FROM sqlite_master
            WHERE type='index'
            AND tbl_name='YoFi.V3.ImportReviewTransactions'
            AND name LIKE '%TenantId_ExternalId%'";
        var indexName = await command.ExecuteScalarAsync();

        // Then: Composite index should exist
        Assert.That(indexName, Is.Not.Null);
        Assert.That(indexName!.ToString(), Does.Contain("TenantId_ExternalId"));
    }

    [Test]
    public async Task ImportReviewTransaction_DuplicateStatusDefaultsToNew()
    {
        // Given: An import review transaction without DuplicateStatus explicitly set
        var transaction = new ImportReviewTransaction
        {
            Date = DateOnly.FromDateTime(DateTime.Now),
            Payee = "Test Payee",
            Amount = 100m,
            TenantId = _tenant1.Id
        };

        // When: Saving the transaction
        _context.ImportReviewTransactions.Add(transaction);
        await _context.SaveChangesAsync();

        // Then: DuplicateStatus should default to New
        var retrieved = await _context.ImportReviewTransactions.FindAsync(transaction.Id);
        Assert.That(retrieved, Is.Not.Null);
        Assert.That(retrieved!.DuplicateStatus, Is.EqualTo(DuplicateStatus.New));
    }

    [Test]
    public async Task ImportReviewTransaction_CanSetDuplicateStatusToExactDuplicate()
    {
        // Given: An import review transaction marked as exact duplicate
        var transaction = new ImportReviewTransaction
        {
            Date = DateOnly.FromDateTime(DateTime.Now),
            Payee = "Test Payee",
            Amount = 100m,
            DuplicateStatus = DuplicateStatus.ExactDuplicate,
            DuplicateOfKey = Guid.NewGuid(),
            TenantId = _tenant1.Id
        };

        // When: Saving the transaction
        _context.ImportReviewTransactions.Add(transaction);
        await _context.SaveChangesAsync();

        // Then: DuplicateStatus should be ExactDuplicate
        var retrieved = await _context.ImportReviewTransactions.FindAsync(transaction.Id);
        Assert.That(retrieved, Is.Not.Null);
        Assert.That(retrieved!.DuplicateStatus, Is.EqualTo(DuplicateStatus.ExactDuplicate));
        Assert.That(retrieved.DuplicateOfKey, Is.Not.Null);
    }

    [Test]
    public async Task ImportReviewTransaction_CanSetDuplicateStatusToPotentialDuplicate()
    {
        // Given: An import review transaction marked as potential duplicate
        var duplicateKey = Guid.NewGuid();
        var transaction = new ImportReviewTransaction
        {
            Date = DateOnly.FromDateTime(DateTime.Now),
            Payee = "Test Payee",
            Amount = 100m,
            DuplicateStatus = DuplicateStatus.PotentialDuplicate,
            DuplicateOfKey = duplicateKey,
            TenantId = _tenant1.Id
        };

        // When: Saving the transaction
        _context.ImportReviewTransactions.Add(transaction);
        await _context.SaveChangesAsync();

        // Then: DuplicateStatus should be PotentialDuplicate and DuplicateOfKey should be preserved
        var retrieved = await _context.ImportReviewTransactions.FindAsync(transaction.Id);
        Assert.That(retrieved, Is.Not.Null);
        Assert.That(retrieved!.DuplicateStatus, Is.EqualTo(DuplicateStatus.PotentialDuplicate));
        Assert.That(retrieved.DuplicateOfKey, Is.EqualTo(duplicateKey));
    }

    [Test]
    public async Task ImportReviewTransaction_DuplicateOfKeyCanBeNull()
    {
        // Given: An import review transaction with null DuplicateOfKey (new transaction)
        var transaction = new ImportReviewTransaction
        {
            Date = DateOnly.FromDateTime(DateTime.Now),
            Payee = "Test Payee",
            Amount = 100m,
            DuplicateStatus = DuplicateStatus.New,
            DuplicateOfKey = null,
            TenantId = _tenant1.Id
        };

        // When: Saving the transaction
        _context.ImportReviewTransactions.Add(transaction);
        await _context.SaveChangesAsync();

        // Then: DuplicateOfKey should be null
        var retrieved = await _context.ImportReviewTransactions.FindAsync(transaction.Id);
        Assert.That(retrieved, Is.Not.Null);
        Assert.That(retrieved!.DuplicateOfKey, Is.Null);
    }

    [Test]
    public async Task ImportReviewTransaction_CanCreateWithAllFields()
    {
        // Given: An import review transaction with all fields populated
        var duplicateKey = Guid.NewGuid();
        var transaction = new ImportReviewTransaction
        {
            Date = DateOnly.FromDateTime(DateTime.Now),
            Payee = "Test Payee",
            Amount = 100.50m,
            Source = "Chase Checking 1234",
            ExternalId = "FITID-20241225-ABC123",
            Memo = "Weekly grocery shopping",
            DuplicateStatus = DuplicateStatus.PotentialDuplicate,
            DuplicateOfKey = duplicateKey,
            TenantId = _tenant1.Id
        };

        // When: Saving the transaction
        _context.ImportReviewTransactions.Add(transaction);
        await _context.SaveChangesAsync();

        // Then: All fields should be persisted
        var retrieved = await _context.ImportReviewTransactions.FindAsync(transaction.Id);
        Assert.That(retrieved, Is.Not.Null);
        Assert.That(retrieved!.Payee, Is.EqualTo("Test Payee"));
        Assert.That(retrieved.Amount, Is.EqualTo(100.50m));
        Assert.That(retrieved.Source, Is.EqualTo("Chase Checking 1234"));
        Assert.That(retrieved.ExternalId, Is.EqualTo("FITID-20241225-ABC123"));
        Assert.That(retrieved.Memo, Is.EqualTo("Weekly grocery shopping"));
        Assert.That(retrieved.DuplicateStatus, Is.EqualTo(DuplicateStatus.PotentialDuplicate));
        Assert.That(retrieved.DuplicateOfKey, Is.EqualTo(duplicateKey));
    }

    [Test]
    public async Task ImportReviewTransaction_CanCreateWithMinimalFields()
    {
        // Given: An import review transaction with only required fields
        var transaction = new ImportReviewTransaction
        {
            Date = DateOnly.FromDateTime(DateTime.Now),
            Payee = "Test Payee",
            Amount = 100m,
            TenantId = _tenant1.Id
            // Source, ExternalId, Memo, DuplicateOfKey intentionally not set (should be null/default)
        };

        // When: Saving the transaction
        _context.ImportReviewTransactions.Add(transaction);
        await _context.SaveChangesAsync();

        // Then: Transaction should be saved with nullable fields as null and defaults applied
        var retrieved = await _context.ImportReviewTransactions.FindAsync(transaction.Id);
        Assert.That(retrieved, Is.Not.Null);
        Assert.That(retrieved!.Payee, Is.EqualTo("Test Payee"));
        Assert.That(retrieved.Source, Is.Null);
        Assert.That(retrieved.ExternalId, Is.Null);
        Assert.That(retrieved.Memo, Is.Null);
        Assert.That(retrieved.DuplicateStatus, Is.EqualTo(DuplicateStatus.New)); // Default
        Assert.That(retrieved.DuplicateOfKey, Is.Null);
    }

    [Test]
    public async Task ImportReviewTransaction_NavigationPropertyToTenant()
    {
        // Given: An import review transaction with tenant navigation property
        var transaction = new ImportReviewTransaction
        {
            Date = DateOnly.FromDateTime(DateTime.Now),
            Payee = "Test Payee",
            Amount = 100m,
            TenantId = _tenant1.Id
        };
        _context.ImportReviewTransactions.Add(transaction);
        await _context.SaveChangesAsync();

        // When: Loading transaction with tenant navigation property
        var retrieved = await _context.ImportReviewTransactions
            .Include(t => t.Tenant)
            .FirstAsync(t => t.Id == transaction.Id);

        // Then: Navigation property should be populated
        Assert.That(retrieved.Tenant, Is.Not.Null);
        Assert.That(retrieved.Tenant!.Id, Is.EqualTo(_tenant1.Id));
        Assert.That(retrieved.Tenant.Name, Is.EqualTo(_tenant1.Name));
    }

    [Test]
    public async Task ImportReviewTransaction_SupportsDateRangeQueries()
    {
        // Given: Import review transactions with different dates
        var startDate = DateOnly.FromDateTime(DateTime.Now.AddDays(-10));
        var midDate = DateOnly.FromDateTime(DateTime.Now.AddDays(-5));
        var endDate = DateOnly.FromDateTime(DateTime.Now);

        _context.ImportReviewTransactions.AddRange(
            new ImportReviewTransaction { Date = startDate, Payee = "Old", Amount = 100m, TenantId = _tenant1.Id },
            new ImportReviewTransaction { Date = midDate, Payee = "Mid", Amount = 200m, TenantId = _tenant1.Id },
            new ImportReviewTransaction { Date = endDate, Payee = "New", Amount = 300m, TenantId = _tenant1.Id }
        );
        await _context.SaveChangesAsync();

        // When: Querying for transactions in a date range
        var results = await _context.ImportReviewTransactions
            .Where(t => t.TenantId == _tenant1.Id && t.Date >= midDate && t.Date <= endDate)
            .ToListAsync();

        // Then: Should return only transactions in the range
        Assert.That(results, Has.Count.EqualTo(2));
        Assert.That(results.All(t => t.Date >= midDate && t.Date <= endDate), Is.True);
    }

    [Test]
    public async Task ImportReviewTransaction_CanQueryByDuplicateStatus()
    {
        // Given: Import review transactions with different duplicate statuses
        _context.ImportReviewTransactions.AddRange(
            new ImportReviewTransaction { Date = DateOnly.FromDateTime(DateTime.Now), Payee = "New 1", Amount = 100m, DuplicateStatus = DuplicateStatus.New, TenantId = _tenant1.Id },
            new ImportReviewTransaction { Date = DateOnly.FromDateTime(DateTime.Now), Payee = "New 2", Amount = 200m, DuplicateStatus = DuplicateStatus.New, TenantId = _tenant1.Id },
            new ImportReviewTransaction { Date = DateOnly.FromDateTime(DateTime.Now), Payee = "Exact Dup", Amount = 300m, DuplicateStatus = DuplicateStatus.ExactDuplicate, DuplicateOfKey = Guid.NewGuid(), TenantId = _tenant1.Id },
            new ImportReviewTransaction { Date = DateOnly.FromDateTime(DateTime.Now), Payee = "Potential Dup", Amount = 400m, DuplicateStatus = DuplicateStatus.PotentialDuplicate, DuplicateOfKey = Guid.NewGuid(), TenantId = _tenant1.Id }
        );
        await _context.SaveChangesAsync();

        // When: Querying for new transactions only
        var newTransactions = await _context.ImportReviewTransactions
            .Where(t => t.TenantId == _tenant1.Id && t.DuplicateStatus == DuplicateStatus.New)
            .ToListAsync();

        // Then: Should return only new transactions
        Assert.That(newTransactions, Has.Count.EqualTo(2));
        Assert.That(newTransactions.All(t => t.DuplicateStatus == DuplicateStatus.New), Is.True);

        // And: Should be able to query for duplicates
        var duplicates = await _context.ImportReviewTransactions
            .Where(t => t.TenantId == _tenant1.Id && t.DuplicateStatus != DuplicateStatus.New)
            .ToListAsync();
        Assert.That(duplicates, Has.Count.EqualTo(2));
    }

    [Test]
    public async Task ImportReviewTransaction_DecimalAmountPrecisionIsPreserved()
    {
        // Given: An import review transaction with a precise decimal amount
        var preciseAmount = 123.456789m;
        var transaction = new ImportReviewTransaction
        {
            Date = DateOnly.FromDateTime(DateTime.Now),
            Payee = "Test Payee",
            Amount = preciseAmount,
            TenantId = _tenant1.Id
        };

        _context.ImportReviewTransactions.Add(transaction);
        await _context.SaveChangesAsync();
        var id = transaction.Id;

        // When: Retrieving the transaction
        var retrieved = await _context.ImportReviewTransactions.FindAsync(id);

        // Then: The decimal precision should be preserved
        Assert.That(retrieved, Is.Not.Null);
        Assert.That(retrieved!.Amount, Is.EqualTo(preciseAmount));
    }

    [Test]
    public async Task ImportReviewTransaction_ExternalIdMaxLengthIs100()
    {
        // Given: An import review transaction with ExternalId exactly at max length (100 chars)
        var externalId100 = new string('F', 100);
        var transaction = new ImportReviewTransaction
        {
            Date = DateOnly.FromDateTime(DateTime.Now),
            Payee = "Test Payee",
            Amount = 100m,
            ExternalId = externalId100,
            TenantId = _tenant1.Id
        };

        // When: Saving the transaction
        _context.ImportReviewTransactions.Add(transaction);
        await _context.SaveChangesAsync();

        // Then: ExternalId should be saved without truncation
        var retrieved = await _context.ImportReviewTransactions.FindAsync(transaction.Id);
        Assert.That(retrieved, Is.Not.Null);
        Assert.That(retrieved!.ExternalId, Is.EqualTo(externalId100));
        Assert.That(retrieved.ExternalId!.Length, Is.EqualTo(100));
    }
}
