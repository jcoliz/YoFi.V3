using Microsoft.EntityFrameworkCore;
using YoFi.V3.Data;
using YoFi.V3.Entities.Models;
using YoFi.V3.Entities.Tenancy;

namespace YoFi.V3.Tests.Integration.Data;

/// <summary>
/// Integration tests for Transaction entity and tenant-scoped data operations.
/// These tests verify database behavior, tenant isolation, and EF Core configuration.
/// </summary>
public class TransactionTests
{
    private ApplicationDbContext _context;
    private DbContextOptions<ApplicationDbContext> _options;
    private Tenant _tenant1;
    private Tenant _tenant2;

    [SetUp]
    public async Task Setup()
    {
        // Use in-memory database for testing
        _options = new DbContextOptionsBuilder<ApplicationDbContext>()
            .UseSqlite("DataSource=:memory:")
            .Options;

        _context = new ApplicationDbContext(_options);
        _context.Database.OpenConnection(); // Keep in-memory DB alive
        _context.Database.EnsureCreated();

        // Create test tenants
        _tenant1 = new Tenant { Name = "Tenant 1", Description = "First test tenant" };
        _tenant2 = new Tenant { Name = "Tenant 2", Description = "Second test tenant" };
        _context.Tenants.AddRange(_tenant1, _tenant2);
        await _context.SaveChangesAsync();
    }

    [TearDown]
    public void TearDown()
    {
        _context.Database.CloseConnection();
        _context.Dispose();
    }

    [Test]
    public async Task Transaction_HasCorrectTableName()
    {
        // Given: A transaction
        var transaction = new Transaction
        {
            Date = DateOnly.FromDateTime(DateTime.Now),
            Payee = "Test Payee",
            Amount = 100.00m,
            TenantId = _tenant1.Id
        };

        _context.Transactions.Add(transaction);
        await _context.SaveChangesAsync();

        // When: Checking the table name in the database
        var connection = _context.Database.GetDbConnection();
        await connection.OpenAsync();
        using var command = connection.CreateCommand();
        command.CommandText = "SELECT name FROM sqlite_master WHERE type='table' AND name='YoFi.V3.Transactions'";
        var tableName = await command.ExecuteScalarAsync();

        // Then: The table should exist with the correct name
        Assert.That(tableName, Is.EqualTo("YoFi.V3.Transactions"));
    }

    [Test]
    public async Task Transaction_IdIsAutoGenerated_KeyIsPreset()
    {
        // Given: A transaction without Id explicitly set
        var transaction = new Transaction
        {
            Date = DateOnly.FromDateTime(DateTime.Now),
            Payee = "Test Payee",
            Amount = 100.00m,
            TenantId = _tenant1.Id
        };

        Assert.That(transaction.Id, Is.EqualTo(0)); // Initially zero
        var initialKey = transaction.Key;
        Assert.That(initialKey, Is.Not.EqualTo(Guid.Empty)); // Key is auto-generated on construction

        // When: Adding and saving the transaction
        _context.Transactions.Add(transaction);
        await _context.SaveChangesAsync();

        // Then: Id should be auto-generated, Key should remain the same
        Assert.That(transaction.Id, Is.GreaterThan(0));
        Assert.That(transaction.Key, Is.EqualTo(initialKey)); // Key doesn't change
        Assert.That(transaction.Key, Is.Not.EqualTo(Guid.Empty));
    }

    [Test]
    public async Task Transaction_TenantIdIsRequired()
    {
        // Given: A transaction without a TenantId (0 is invalid for foreign key)
        var transaction = new Transaction
        {
            Date = DateOnly.FromDateTime(DateTime.Now),
            Payee = "Test Payee",
            Amount = 100.00m,
            TenantId = 0 // Invalid
        };

        _context.Transactions.Add(transaction);

        // When/Then: Saving should fail with a database constraint error
        Assert.ThrowsAsync<DbUpdateException>(async () => await _context.SaveChangesAsync());
    }

    [Test]
    public async Task Transaction_TenantIdForeignKeyConstraint()
    {
        // Given: A transaction with a non-existent TenantId
        var transaction = new Transaction
        {
            Date = DateOnly.FromDateTime(DateTime.Now),
            Payee = "Test Payee",
            Amount = 100.00m,
            TenantId = 999999 // Non-existent tenant
        };

        _context.Transactions.Add(transaction);

        // When/Then: Saving should fail due to foreign key constraint
        Assert.ThrowsAsync<DbUpdateException>(async () => await _context.SaveChangesAsync());
    }

    [Test]
    public async Task Transaction_CanQueryByTenantId()
    {
        // Given: Transactions for multiple tenants
        _context.Transactions.AddRange(
            new Transaction { Date = DateOnly.FromDateTime(DateTime.Now), Payee = "Payee 1", Amount = 100m, TenantId = _tenant1.Id },
            new Transaction { Date = DateOnly.FromDateTime(DateTime.Now), Payee = "Payee 2", Amount = 200m, TenantId = _tenant1.Id },
            new Transaction { Date = DateOnly.FromDateTime(DateTime.Now), Payee = "Payee 3", Amount = 300m, TenantId = _tenant2.Id }
        );
        await _context.SaveChangesAsync();

        // When: Querying for tenant 1's transactions
        var tenant1Transactions = await _context.Transactions
            .Where(t => t.TenantId == _tenant1.Id)
            .ToListAsync();

        // Then: Should only return transactions for tenant 1
        Assert.That(tenant1Transactions, Has.Count.EqualTo(2));
        Assert.That(tenant1Transactions.All(t => t.TenantId == _tenant1.Id), Is.True);
    }

    [Test]
    public async Task Transaction_TenantsAreIsolated()
    {
        // Given: Transactions for different tenants
        var tenant1Transaction = new Transaction
        {
            Date = DateOnly.FromDateTime(DateTime.Now),
            Payee = "Tenant 1 Payee",
            Amount = 100m,
            TenantId = _tenant1.Id
        };
        var tenant2Transaction = new Transaction
        {
            Date = DateOnly.FromDateTime(DateTime.Now),
            Payee = "Tenant 2 Payee",
            Amount = 200m,
            TenantId = _tenant2.Id
        };

        _context.Transactions.AddRange(tenant1Transaction, tenant2Transaction);
        await _context.SaveChangesAsync();

        // When: Querying each tenant's transactions
        var tenant1Transactions = await _context.Transactions
            .Where(t => t.TenantId == _tenant1.Id)
            .ToListAsync();
        var tenant2Transactions = await _context.Transactions
            .Where(t => t.TenantId == _tenant2.Id)
            .ToListAsync();

        // Then: Each tenant should only see their own transactions
        Assert.That(tenant1Transactions, Has.Count.EqualTo(1));
        Assert.That(tenant2Transactions, Has.Count.EqualTo(1));
        Assert.That(tenant1Transactions[0].Payee, Is.EqualTo("Tenant 1 Payee"));
        Assert.That(tenant2Transactions[0].Payee, Is.EqualTo("Tenant 2 Payee"));
    }

    [Test]
    public async Task Transaction_CanBeUpdated()
    {
        // Given: An existing transaction
        var transaction = new Transaction
        {
            Date = DateOnly.FromDateTime(DateTime.Now),
            Payee = "Original Payee",
            Amount = 100m,
            TenantId = _tenant1.Id
        };
        _context.Transactions.Add(transaction);
        await _context.SaveChangesAsync();
        var id = transaction.Id;

        // When: Updating the transaction
        transaction.Payee = "Updated Payee";
        transaction.Amount = 200m;
        await _context.SaveChangesAsync();

        // Then: Changes should be persisted
        var updated = await _context.Transactions.FindAsync(id);
        Assert.That(updated, Is.Not.Null);
        Assert.That(updated!.Payee, Is.EqualTo("Updated Payee"));
        Assert.That(updated.Amount, Is.EqualTo(200m));
    }

    [Test]
    public async Task Transaction_CanBeDeleted()
    {
        // Given: An existing transaction
        var transaction = new Transaction
        {
            Date = DateOnly.FromDateTime(DateTime.Now),
            Payee = "Test Payee",
            Amount = 100m,
            TenantId = _tenant1.Id
        };
        _context.Transactions.Add(transaction);
        await _context.SaveChangesAsync();
        var id = transaction.Id;

        // When: Deleting the transaction
        _context.Transactions.Remove(transaction);
        await _context.SaveChangesAsync();

        // Then: Transaction should be removed from database
        var deleted = await _context.Transactions.FindAsync(id);
        Assert.That(deleted, Is.Null);
    }

    [Test]
    public async Task Transaction_CanQueryByKey()
    {
        // Given: A transaction with a generated key
        var transaction = new Transaction
        {
            Date = DateOnly.FromDateTime(DateTime.Now),
            Payee = "Test Payee",
            Amount = 100m,
            TenantId = _tenant1.Id
        };
        _context.Transactions.Add(transaction);
        await _context.SaveChangesAsync();
        var key = transaction.Key;

        // When: Querying by Key
        var found = await _context.Transactions
            .FirstOrDefaultAsync(t => t.Key == key);

        // Then: Should find the transaction
        Assert.That(found, Is.Not.Null);
        Assert.That(found!.Payee, Is.EqualTo("Test Payee"));
        Assert.That(found.Key, Is.EqualTo(key));
    }

    [Test]
    public async Task Transaction_SupportsDateRangeQueries()
    {
        // Given: Transactions with different dates
        var startDate = DateOnly.FromDateTime(DateTime.Now.AddDays(-10));
        var midDate = DateOnly.FromDateTime(DateTime.Now.AddDays(-5));
        var endDate = DateOnly.FromDateTime(DateTime.Now);

        _context.Transactions.AddRange(
            new Transaction { Date = startDate, Payee = "Old", Amount = 100m, TenantId = _tenant1.Id },
            new Transaction { Date = midDate, Payee = "Mid", Amount = 200m, TenantId = _tenant1.Id },
            new Transaction { Date = endDate, Payee = "New", Amount = 300m, TenantId = _tenant1.Id }
        );
        await _context.SaveChangesAsync();

        // When: Querying for transactions in a date range
        var results = await _context.Transactions
            .Where(t => t.TenantId == _tenant1.Id && t.Date >= midDate && t.Date <= endDate)
            .ToListAsync();

        // Then: Should return only transactions in the range
        Assert.That(results, Has.Count.EqualTo(2));
        Assert.That(results.All(t => t.Date >= midDate && t.Date <= endDate), Is.True);
    }

    [Test]
    public async Task Transaction_SupportsOrderingByDate()
    {
        // Given: Transactions with different dates
        var date1 = DateOnly.FromDateTime(DateTime.Now.AddDays(-5));
        var date2 = DateOnly.FromDateTime(DateTime.Now.AddDays(-3));
        var date3 = DateOnly.FromDateTime(DateTime.Now);

        _context.Transactions.AddRange(
            new Transaction { Date = date2, Payee = "Mid", Amount = 200m, TenantId = _tenant1.Id },
            new Transaction { Date = date1, Payee = "Old", Amount = 100m, TenantId = _tenant1.Id },
            new Transaction { Date = date3, Payee = "New", Amount = 300m, TenantId = _tenant1.Id }
        );
        await _context.SaveChangesAsync();

        // When: Querying with ordering by date descending
        var results = await _context.Transactions
            .Where(t => t.TenantId == _tenant1.Id)
            .OrderByDescending(t => t.Date)
            .ToListAsync();

        // Then: Should return transactions in descending date order
        Assert.That(results, Has.Count.EqualTo(3));
        Assert.That(results[0].Date, Is.EqualTo(date3));
        Assert.That(results[1].Date, Is.EqualTo(date2));
        Assert.That(results[2].Date, Is.EqualTo(date1));
    }

    [Test]
    public async Task Transaction_DecimalAmountPrecisionIsPreserved()
    {
        // Given: A transaction with a precise decimal amount
        var preciseAmount = 123.456789m;
        var transaction = new Transaction
        {
            Date = DateOnly.FromDateTime(DateTime.Now),
            Payee = "Test Payee",
            Amount = preciseAmount,
            TenantId = _tenant1.Id
        };

        _context.Transactions.Add(transaction);
        await _context.SaveChangesAsync();
        var id = transaction.Id;

        // When: Retrieving the transaction
        var retrieved = await _context.Transactions.FindAsync(id);

        // Then: The decimal precision should be preserved
        Assert.That(retrieved, Is.Not.Null);
        Assert.That(retrieved!.Amount, Is.EqualTo(preciseAmount));
    }

    [Test]
    public async Task Transaction_SupportsNegativeAmounts()
    {
        // Given: A transaction with a negative amount
        var transaction = new Transaction
        {
            Date = DateOnly.FromDateTime(DateTime.Now),
            Payee = "Refund",
            Amount = -50.00m,
            TenantId = _tenant1.Id
        };

        _context.Transactions.Add(transaction);
        await _context.SaveChangesAsync();

        // When: Retrieving the transaction
        var retrieved = await _context.Transactions.FindAsync(transaction.Id);

        // Then: The negative amount should be preserved
        Assert.That(retrieved, Is.Not.Null);
        Assert.That(retrieved!.Amount, Is.EqualTo(-50.00m));
    }

    [Test]
    public async Task Transaction_PayeeCanBeEmpty()
    {
        // Given: A transaction with an empty payee
        var transaction = new Transaction
        {
            Date = DateOnly.FromDateTime(DateTime.Now),
            Payee = string.Empty,
            Amount = 100m,
            TenantId = _tenant1.Id
        };

        _context.Transactions.Add(transaction);
        await _context.SaveChangesAsync();

        // When: Retrieving the transaction
        var retrieved = await _context.Transactions.FindAsync(transaction.Id);

        // Then: Empty payee should be allowed at database level
        Assert.That(retrieved, Is.Not.Null);
        Assert.That(retrieved!.Payee, Is.EqualTo(string.Empty));
    }

    [Test]
    public async Task Transaction_NavigationPropertyToTenant()
    {
        // Given: A transaction with tenant navigation property
        var transaction = new Transaction
        {
            Date = DateOnly.FromDateTime(DateTime.Now),
            Payee = "Test Payee",
            Amount = 100m,
            TenantId = _tenant1.Id
        };
        _context.Transactions.Add(transaction);
        await _context.SaveChangesAsync();

        // When: Loading transaction with tenant navigation property
        var retrieved = await _context.Transactions
            .Include(t => t.Tenant)
            .FirstAsync(t => t.Id == transaction.Id);

        // Then: Navigation property should be populated
        Assert.That(retrieved.Tenant, Is.Not.Null);
        Assert.That(retrieved.Tenant!.Id, Is.EqualTo(_tenant1.Id));
        Assert.That(retrieved.Tenant.Name, Is.EqualTo(_tenant1.Name));
    }

    [Test]
    public async Task Transaction_KeyIsUniqueAcrossAllTenants()
    {
        // Given: Transactions from different tenants
        var transaction1 = new Transaction
        {
            Date = DateOnly.FromDateTime(DateTime.Now),
            Payee = "Tenant 1 Payee",
            Amount = 100m,
            TenantId = _tenant1.Id
        };
        var transaction2 = new Transaction
        {
            Date = DateOnly.FromDateTime(DateTime.Now),
            Payee = "Tenant 2 Payee",
            Amount = 200m,
            TenantId = _tenant2.Id
        };

        _context.Transactions.AddRange(transaction1, transaction2);
        await _context.SaveChangesAsync();

        // When: Checking the keys
        var allKeys = await _context.Transactions
            .Select(t => t.Key)
            .ToListAsync();

        // Then: All keys should be unique
        Assert.That(allKeys, Is.Unique);
        Assert.That(allKeys, Has.Count.EqualTo(2));
    }
}
