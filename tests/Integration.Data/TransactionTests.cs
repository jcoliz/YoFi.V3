using Microsoft.EntityFrameworkCore;
using YoFi.V3.Data;
using YoFi.V3.Entities.Models;
using YoFi.V3.Entities.Tenancy.Models;

namespace YoFi.V3.Tests.Integration.Data;

/// <summary>
/// Integration tests for Transaction entity and tenant-scoped data operations.
/// These tests verify database behavior, tenant isolation, and EF Core configuration.
/// </summary>
public class TransactionTests
{
    private ApplicationDbContext _context;
    private DbContextOptions<ApplicationDbContext> _options;
    private Tenant _tenant1;
    private Tenant _tenant2;

    [SetUp]
    public async Task Setup()
    {
        // Use in-memory database for testing
        _options = new DbContextOptionsBuilder<ApplicationDbContext>()
            .UseSqlite("DataSource=:memory:")
            .Options;

        _context = new ApplicationDbContext(_options);
        _context.Database.OpenConnection(); // Keep in-memory DB alive
        _context.Database.EnsureCreated();

        // Create test tenants
        _tenant1 = new Tenant { Name = "Tenant 1", Description = "First test tenant" };
        _tenant2 = new Tenant { Name = "Tenant 2", Description = "Second test tenant" };
        _context.Tenants.AddRange(_tenant1, _tenant2);
        await _context.SaveChangesAsync();
    }

    [TearDown]
    public void TearDown()
    {
        _context.Database.CloseConnection();
        _context.Dispose();
    }

    [Test]
    public async Task Transaction_HasCorrectTableName()
    {
        // Given: A transaction
        var transaction = new Transaction
        {
            Date = DateOnly.FromDateTime(DateTime.Now),
            Payee = "Test Payee",
            Amount = 100.00m,
            TenantId = _tenant1.Id
        };

        _context.Transactions.Add(transaction);
        await _context.SaveChangesAsync();

        // When: Checking the table name in the database
        var connection = _context.Database.GetDbConnection();
        await connection.OpenAsync();
        using var command = connection.CreateCommand();
        command.CommandText = "SELECT name FROM sqlite_master WHERE type='table' AND name='YoFi.V3.Transactions'";
        var tableName = await command.ExecuteScalarAsync();

        // Then: The table should exist with the correct name
        Assert.That(tableName, Is.EqualTo("YoFi.V3.Transactions"));
    }

    [Test]
    public async Task Transaction_IdIsAutoGenerated_KeyIsPreset()
    {
        // Given: A transaction without Id explicitly set
        var transaction = new Transaction
        {
            Date = DateOnly.FromDateTime(DateTime.Now),
            Payee = "Test Payee",
            Amount = 100.00m,
            TenantId = _tenant1.Id
        };

        Assert.That(transaction.Id, Is.EqualTo(0)); // Initially zero
        var initialKey = transaction.Key;
        Assert.That(initialKey, Is.Not.EqualTo(Guid.Empty)); // Key is auto-generated on construction

        // When: Adding and saving the transaction
        _context.Transactions.Add(transaction);
        await _context.SaveChangesAsync();

        // Then: Id should be auto-generated, Key should remain the same
        Assert.That(transaction.Id, Is.GreaterThan(0));
        Assert.That(transaction.Key, Is.EqualTo(initialKey)); // Key doesn't change
        Assert.That(transaction.Key, Is.Not.EqualTo(Guid.Empty));
    }

    [Test]
    public async Task Transaction_TenantIdIsRequired()
    {
        // Given: A transaction without a TenantId (0 is invalid for foreign key)
        var transaction = new Transaction
        {
            Date = DateOnly.FromDateTime(DateTime.Now),
            Payee = "Test Payee",
            Amount = 100.00m,
            TenantId = 0 // Invalid
        };

        _context.Transactions.Add(transaction);

        // When/Then: Saving should fail with a database constraint error
        Assert.ThrowsAsync<DbUpdateException>(async () => await _context.SaveChangesAsync());
    }

    [Test]
    public async Task Transaction_TenantIdForeignKeyConstraint()
    {
        // Given: A transaction with a non-existent TenantId
        var transaction = new Transaction
        {
            Date = DateOnly.FromDateTime(DateTime.Now),
            Payee = "Test Payee",
            Amount = 100.00m,
            TenantId = 999999 // Non-existent tenant
        };

        _context.Transactions.Add(transaction);

        // When/Then: Saving should fail due to foreign key constraint
        Assert.ThrowsAsync<DbUpdateException>(async () => await _context.SaveChangesAsync());
    }

    [Test]
    public async Task Transaction_CanQueryByTenantId()
    {
        // Given: Transactions for multiple tenants
        _context.Transactions.AddRange(
            new Transaction { Date = DateOnly.FromDateTime(DateTime.Now), Payee = "Payee 1", Amount = 100m, TenantId = _tenant1.Id },
            new Transaction { Date = DateOnly.FromDateTime(DateTime.Now), Payee = "Payee 2", Amount = 200m, TenantId = _tenant1.Id },
            new Transaction { Date = DateOnly.FromDateTime(DateTime.Now), Payee = "Payee 3", Amount = 300m, TenantId = _tenant2.Id }
        );
        await _context.SaveChangesAsync();

        // When: Querying for tenant 1's transactions
        var tenant1Transactions = await _context.Transactions
            .Where(t => t.TenantId == _tenant1.Id)
            .ToListAsync();

        // Then: Should only return transactions for tenant 1
        Assert.That(tenant1Transactions, Has.Count.EqualTo(2));
        Assert.That(tenant1Transactions.All(t => t.TenantId == _tenant1.Id), Is.True);
    }

    [Test]
    public async Task Transaction_TenantsAreIsolated()
    {
        // Given: Transactions for different tenants
        var tenant1Transaction = new Transaction
        {
            Date = DateOnly.FromDateTime(DateTime.Now),
            Payee = "Tenant 1 Payee",
            Amount = 100m,
            TenantId = _tenant1.Id
        };
        var tenant2Transaction = new Transaction
        {
            Date = DateOnly.FromDateTime(DateTime.Now),
            Payee = "Tenant 2 Payee",
            Amount = 200m,
            TenantId = _tenant2.Id
        };

        _context.Transactions.AddRange(tenant1Transaction, tenant2Transaction);
        await _context.SaveChangesAsync();

        // When: Querying each tenant's transactions
        var tenant1Transactions = await _context.Transactions
            .Where(t => t.TenantId == _tenant1.Id)
            .ToListAsync();
        var tenant2Transactions = await _context.Transactions
            .Where(t => t.TenantId == _tenant2.Id)
            .ToListAsync();

        // Then: Each tenant should only see their own transactions
        Assert.That(tenant1Transactions, Has.Count.EqualTo(1));
        Assert.That(tenant2Transactions, Has.Count.EqualTo(1));
        Assert.That(tenant1Transactions[0].Payee, Is.EqualTo("Tenant 1 Payee"));
        Assert.That(tenant2Transactions[0].Payee, Is.EqualTo("Tenant 2 Payee"));
    }

    [Test]
    public async Task Transaction_CanBeUpdated()
    {
        // Given: An existing transaction
        var transaction = new Transaction
        {
            Date = DateOnly.FromDateTime(DateTime.Now),
            Payee = "Original Payee",
            Amount = 100m,
            TenantId = _tenant1.Id
        };
        _context.Transactions.Add(transaction);
        await _context.SaveChangesAsync();
        var id = transaction.Id;

        // When: Updating the transaction
        transaction.Payee = "Updated Payee";
        transaction.Amount = 200m;
        await _context.SaveChangesAsync();

        // Then: Changes should be persisted
        var updated = await _context.Transactions.FindAsync(id);
        Assert.That(updated, Is.Not.Null);
        Assert.That(updated!.Payee, Is.EqualTo("Updated Payee"));
        Assert.That(updated.Amount, Is.EqualTo(200m));
    }

    [Test]
    public async Task Transaction_CanBeDeleted()
    {
        // Given: An existing transaction
        var transaction = new Transaction
        {
            Date = DateOnly.FromDateTime(DateTime.Now),
            Payee = "Test Payee",
            Amount = 100m,
            TenantId = _tenant1.Id
        };
        _context.Transactions.Add(transaction);
        await _context.SaveChangesAsync();
        var id = transaction.Id;

        // When: Deleting the transaction
        _context.Transactions.Remove(transaction);
        await _context.SaveChangesAsync();

        // Then: Transaction should be removed from database
        var deleted = await _context.Transactions.FindAsync(id);
        Assert.That(deleted, Is.Null);
    }

    [Test]
    public async Task Transaction_CanQueryByKey()
    {
        // Given: A transaction with a generated key
        var transaction = new Transaction
        {
            Date = DateOnly.FromDateTime(DateTime.Now),
            Payee = "Test Payee",
            Amount = 100m,
            TenantId = _tenant1.Id
        };
        _context.Transactions.Add(transaction);
        await _context.SaveChangesAsync();
        var key = transaction.Key;

        // When: Querying by Key
        var found = await _context.Transactions
            .FirstOrDefaultAsync(t => t.Key == key);

        // Then: Should find the transaction
        Assert.That(found, Is.Not.Null);
        Assert.That(found!.Payee, Is.EqualTo("Test Payee"));
        Assert.That(found.Key, Is.EqualTo(key));
    }

    [Test]
    public async Task Transaction_SupportsDateRangeQueries()
    {
        // Given: Transactions with different dates
        var startDate = DateOnly.FromDateTime(DateTime.Now.AddDays(-10));
        var midDate = DateOnly.FromDateTime(DateTime.Now.AddDays(-5));
        var endDate = DateOnly.FromDateTime(DateTime.Now);

        _context.Transactions.AddRange(
            new Transaction { Date = startDate, Payee = "Old", Amount = 100m, TenantId = _tenant1.Id },
            new Transaction { Date = midDate, Payee = "Mid", Amount = 200m, TenantId = _tenant1.Id },
            new Transaction { Date = endDate, Payee = "New", Amount = 300m, TenantId = _tenant1.Id }
        );
        await _context.SaveChangesAsync();

        // When: Querying for transactions in a date range
        var results = await _context.Transactions
            .Where(t => t.TenantId == _tenant1.Id && t.Date >= midDate && t.Date <= endDate)
            .ToListAsync();

        // Then: Should return only transactions in the range
        Assert.That(results, Has.Count.EqualTo(2));
        Assert.That(results.All(t => t.Date >= midDate && t.Date <= endDate), Is.True);
    }

    [Test]
    public async Task Transaction_SupportsOrderingByDate()
    {
        // Given: Transactions with different dates
        var date1 = DateOnly.FromDateTime(DateTime.Now.AddDays(-5));
        var date2 = DateOnly.FromDateTime(DateTime.Now.AddDays(-3));
        var date3 = DateOnly.FromDateTime(DateTime.Now);

        _context.Transactions.AddRange(
            new Transaction { Date = date2, Payee = "Mid", Amount = 200m, TenantId = _tenant1.Id },
            new Transaction { Date = date1, Payee = "Old", Amount = 100m, TenantId = _tenant1.Id },
            new Transaction { Date = date3, Payee = "New", Amount = 300m, TenantId = _tenant1.Id }
        );
        await _context.SaveChangesAsync();

        // When: Querying with ordering by date descending
        var results = await _context.Transactions
            .Where(t => t.TenantId == _tenant1.Id)
            .OrderByDescending(t => t.Date)
            .ToListAsync();

        // Then: Should return transactions in descending date order
        Assert.That(results, Has.Count.EqualTo(3));
        Assert.That(results[0].Date, Is.EqualTo(date3));
        Assert.That(results[1].Date, Is.EqualTo(date2));
        Assert.That(results[2].Date, Is.EqualTo(date1));
    }

    [Test]
    public async Task Transaction_DecimalAmountPrecisionIsPreserved()
    {
        // Given: A transaction with a precise decimal amount
        var preciseAmount = 123.456789m;
        var transaction = new Transaction
        {
            Date = DateOnly.FromDateTime(DateTime.Now),
            Payee = "Test Payee",
            Amount = preciseAmount,
            TenantId = _tenant1.Id
        };

        _context.Transactions.Add(transaction);
        await _context.SaveChangesAsync();
        var id = transaction.Id;

        // When: Retrieving the transaction
        var retrieved = await _context.Transactions.FindAsync(id);

        // Then: The decimal precision should be preserved
        Assert.That(retrieved, Is.Not.Null);
        Assert.That(retrieved!.Amount, Is.EqualTo(preciseAmount));
    }

    [Test]
    public async Task Transaction_SupportsNegativeAmounts()
    {
        // Given: A transaction with a negative amount
        var transaction = new Transaction
        {
            Date = DateOnly.FromDateTime(DateTime.Now),
            Payee = "Refund",
            Amount = -50.00m,
            TenantId = _tenant1.Id
        };

        _context.Transactions.Add(transaction);
        await _context.SaveChangesAsync();

        // When: Retrieving the transaction
        var retrieved = await _context.Transactions.FindAsync(transaction.Id);

        // Then: The negative amount should be preserved
        Assert.That(retrieved, Is.Not.Null);
        Assert.That(retrieved!.Amount, Is.EqualTo(-50.00m));
    }

    [Test]
    public async Task Transaction_PayeeCanBeEmpty()
    {
        // Given: A transaction with an empty payee
        var transaction = new Transaction
        {
            Date = DateOnly.FromDateTime(DateTime.Now),
            Payee = string.Empty,
            Amount = 100m,
            TenantId = _tenant1.Id
        };

        _context.Transactions.Add(transaction);
        await _context.SaveChangesAsync();

        // When: Retrieving the transaction
        var retrieved = await _context.Transactions.FindAsync(transaction.Id);

        // Then: Empty payee should be allowed at database level
        Assert.That(retrieved, Is.Not.Null);
        Assert.That(retrieved!.Payee, Is.EqualTo(string.Empty));
    }

    [Test]
    public async Task Transaction_NavigationPropertyToTenant()
    {
        // Given: A transaction with tenant navigation property
        var transaction = new Transaction
        {
            Date = DateOnly.FromDateTime(DateTime.Now),
            Payee = "Test Payee",
            Amount = 100m,
            TenantId = _tenant1.Id
        };
        _context.Transactions.Add(transaction);
        await _context.SaveChangesAsync();

        // When: Loading transaction with tenant navigation property
        var retrieved = await _context.Transactions
            .Include(t => t.Tenant)
            .FirstAsync(t => t.Id == transaction.Id);

        // Then: Navigation property should be populated
        Assert.That(retrieved.Tenant, Is.Not.Null);
        Assert.That(retrieved.Tenant!.Id, Is.EqualTo(_tenant1.Id));
        Assert.That(retrieved.Tenant.Name, Is.EqualTo(_tenant1.Name));
    }

    [Test]
    public async Task Transaction_KeyIsUniqueAcrossAllTenants()
    {
        // Given: Transactions from different tenants
        var transaction1 = new Transaction
        {
            Date = DateOnly.FromDateTime(DateTime.Now),
            Payee = "Tenant 1 Payee",
            Amount = 100m,
            TenantId = _tenant1.Id
        };
        var transaction2 = new Transaction
        {
            Date = DateOnly.FromDateTime(DateTime.Now),
            Payee = "Tenant 2 Payee",
            Amount = 200m,
            TenantId = _tenant2.Id
        };

        _context.Transactions.AddRange(transaction1, transaction2);
        await _context.SaveChangesAsync();

        // When: Checking the keys
        var allKeys = await _context.Transactions
            .Select(t => t.Key)
            .ToListAsync();

        // Then: All keys should be unique
        Assert.That(allKeys, Is.Unique);
        Assert.That(allKeys, Has.Count.EqualTo(2));
    }

    [Test]
    public async Task Transaction_CanCreateWithAllFields()
    {
        // Given: A transaction with all fields populated
        var transaction = new Transaction
        {
            Date = DateOnly.FromDateTime(DateTime.Now),
            Payee = "Test Payee",
            Amount = 100.50m,
            Source = "Chase Checking 1234",
            ExternalId = "TXN20241225-ABC123",
            Memo = "Weekly grocery shopping",
            TenantId = _tenant1.Id
        };

        // When: Saving the transaction
        _context.Transactions.Add(transaction);
        await _context.SaveChangesAsync();

        // Then: All fields should be persisted
        var retrieved = await _context.Transactions.FindAsync(transaction.Id);
        Assert.That(retrieved, Is.Not.Null);
        Assert.That(retrieved!.Payee, Is.EqualTo("Test Payee"));
        Assert.That(retrieved.Amount, Is.EqualTo(100.50m));
        Assert.That(retrieved.Source, Is.EqualTo("Chase Checking 1234"));
        Assert.That(retrieved.ExternalId, Is.EqualTo("TXN20241225-ABC123"));
        Assert.That(retrieved.Memo, Is.EqualTo("Weekly grocery shopping"));
    }

    [Test]
    public async Task Transaction_CanCreateWithMinimalFields()
    {
        // Given: A transaction with only required fields (Date, Payee, Amount)
        var transaction = new Transaction
        {
            Date = DateOnly.FromDateTime(DateTime.Now),
            Payee = "Test Payee",
            Amount = 100m,
            TenantId = _tenant1.Id
            // Source, ExternalId, Memo intentionally not set (should be null)
        };

        // When: Saving the transaction
        _context.Transactions.Add(transaction);
        await _context.SaveChangesAsync();

        // Then: Transaction should be saved with nullable fields as null
        var retrieved = await _context.Transactions.FindAsync(transaction.Id);
        Assert.That(retrieved, Is.Not.Null);
        Assert.That(retrieved!.Payee, Is.EqualTo("Test Payee"));
        Assert.That(retrieved.Source, Is.Null);
        Assert.That(retrieved.ExternalId, Is.Null);
        Assert.That(retrieved.Memo, Is.Null);
    }

    [Test]
    public async Task Transaction_CanUpdateAllFields()
    {
        // Given: An existing transaction with initial values
        var transaction = new Transaction
        {
            Date = DateOnly.FromDateTime(DateTime.Now),
            Payee = "Original Payee",
            Amount = 100m,
            Source = "Original Source",
            ExternalId = "ORIG-123",
            Memo = "Original memo",
            TenantId = _tenant1.Id
        };
        _context.Transactions.Add(transaction);
        await _context.SaveChangesAsync();

        // When: Updating all fields
        transaction.Payee = "Updated Payee";
        transaction.Amount = 200m;
        transaction.Source = "Updated Source";
        transaction.ExternalId = "UPDATED-456";
        transaction.Memo = "Updated memo";
        await _context.SaveChangesAsync();

        // Then: All fields should be updated
        var retrieved = await _context.Transactions.FindAsync(transaction.Id);
        Assert.That(retrieved, Is.Not.Null);
        Assert.That(retrieved!.Payee, Is.EqualTo("Updated Payee"));
        Assert.That(retrieved.Amount, Is.EqualTo(200m));
        Assert.That(retrieved.Source, Is.EqualTo("Updated Source"));
        Assert.That(retrieved.ExternalId, Is.EqualTo("UPDATED-456"));
        Assert.That(retrieved.Memo, Is.EqualTo("Updated memo"));
    }

    [Test]
    public async Task Transaction_CanClearNullableFields()
    {
        // Given: An existing transaction with all fields populated
        var transaction = new Transaction
        {
            Date = DateOnly.FromDateTime(DateTime.Now),
            Payee = "Test Payee",
            Amount = 100m,
            Source = "Chase Checking 1234",
            ExternalId = "TXN-123",
            Memo = "Test memo",
            TenantId = _tenant1.Id
        };
        _context.Transactions.Add(transaction);
        await _context.SaveChangesAsync();

        // When: Clearing nullable fields
        transaction.Source = null;
        transaction.ExternalId = null;
        transaction.Memo = null;
        await _context.SaveChangesAsync();

        // Then: Nullable fields should be null
        var retrieved = await _context.Transactions.FindAsync(transaction.Id);
        Assert.That(retrieved, Is.Not.Null);
        Assert.That(retrieved!.Source, Is.Null);
        Assert.That(retrieved.ExternalId, Is.Null);
        Assert.That(retrieved.Memo, Is.Null);
    }

    [Test]
    public async Task Transaction_SourceMaxLengthIs200()
    {
        // Given: A transaction with Source exactly at max length (200 chars)
        var source200 = new string('A', 200);
        var transaction = new Transaction
        {
            Date = DateOnly.FromDateTime(DateTime.Now),
            Payee = "Test Payee",
            Amount = 100m,
            Source = source200,
            TenantId = _tenant1.Id
        };

        // When: Saving the transaction
        _context.Transactions.Add(transaction);
        await _context.SaveChangesAsync();

        // Then: Source should be saved without truncation
        var retrieved = await _context.Transactions.FindAsync(transaction.Id);
        Assert.That(retrieved, Is.Not.Null);
        Assert.That(retrieved!.Source, Is.EqualTo(source200));
        Assert.That(retrieved.Source!.Length, Is.EqualTo(200));
    }

    [Test]
    public async Task Transaction_ExternalIdMaxLengthIs100()
    {
        // Given: A transaction with ExternalId exactly at max length (100 chars)
        var externalId100 = new string('B', 100);
        var transaction = new Transaction
        {
            Date = DateOnly.FromDateTime(DateTime.Now),
            Payee = "Test Payee",
            Amount = 100m,
            ExternalId = externalId100,
            TenantId = _tenant1.Id
        };

        // When: Saving the transaction
        _context.Transactions.Add(transaction);
        await _context.SaveChangesAsync();

        // Then: ExternalId should be saved without truncation
        var retrieved = await _context.Transactions.FindAsync(transaction.Id);
        Assert.That(retrieved, Is.Not.Null);
        Assert.That(retrieved!.ExternalId, Is.EqualTo(externalId100));
        Assert.That(retrieved.ExternalId!.Length, Is.EqualTo(100));
    }

    [Test]
    public async Task Transaction_MemoMaxLengthIs1000()
    {
        // Given: A transaction with Memo exactly at max length (1000 chars)
        var memo1000 = new string('C', 1000);
        var transaction = new Transaction
        {
            Date = DateOnly.FromDateTime(DateTime.Now),
            Payee = "Test Payee",
            Amount = 100m,
            Memo = memo1000,
            TenantId = _tenant1.Id
        };

        // When: Saving the transaction
        _context.Transactions.Add(transaction);
        await _context.SaveChangesAsync();

        // Then: Memo should be saved without truncation
        var retrieved = await _context.Transactions.FindAsync(transaction.Id);
        Assert.That(retrieved, Is.Not.Null);
        Assert.That(retrieved!.Memo, Is.EqualTo(memo1000));
        Assert.That(retrieved.Memo!.Length, Is.EqualTo(1000));
    }

    [Test]
    public async Task Transaction_DuplicateExternalIdWithinSameTenant_IsAllowed()
    {
        // Given: Two transactions with the same ExternalId in the same tenant
        var externalId = "DUPLICATE-123";
        var transaction1 = new Transaction
        {
            Date = DateOnly.FromDateTime(DateTime.Now),
            Payee = "Payee 1",
            Amount = 100m,
            ExternalId = externalId,
            TenantId = _tenant1.Id
        };
        var transaction2 = new Transaction
        {
            Date = DateOnly.FromDateTime(DateTime.Now),
            Payee = "Payee 2",
            Amount = 200m,
            ExternalId = externalId,
            TenantId = _tenant1.Id
        };

        // When: Saving both transactions
        _context.Transactions.AddRange(transaction1, transaction2);
        await _context.SaveChangesAsync();

        // Then: Both should be saved (no uniqueness constraint on ExternalId)
        var duplicates = await _context.Transactions
            .Where(t => t.TenantId == _tenant1.Id && t.ExternalId == externalId)
            .ToListAsync();
        Assert.That(duplicates, Has.Count.EqualTo(2));
    }

    [Test]
    public async Task Transaction_SameExternalIdAcrossDifferentTenants_IsAllowed()
    {
        // Given: Transactions with the same ExternalId in different tenants
        var externalId = "SHARED-123";
        var transaction1 = new Transaction
        {
            Date = DateOnly.FromDateTime(DateTime.Now),
            Payee = "Tenant 1 Payee",
            Amount = 100m,
            ExternalId = externalId,
            TenantId = _tenant1.Id
        };
        var transaction2 = new Transaction
        {
            Date = DateOnly.FromDateTime(DateTime.Now),
            Payee = "Tenant 2 Payee",
            Amount = 200m,
            ExternalId = externalId,
            TenantId = _tenant2.Id
        };

        // When: Saving both transactions
        _context.Transactions.AddRange(transaction1, transaction2);
        await _context.SaveChangesAsync();

        // Then: Both should be saved successfully
        var tenant1Transaction = await _context.Transactions
            .FirstAsync(t => t.TenantId == _tenant1.Id && t.ExternalId == externalId);
        var tenant2Transaction = await _context.Transactions
            .FirstAsync(t => t.TenantId == _tenant2.Id && t.ExternalId == externalId);

        Assert.That(tenant1Transaction.Payee, Is.EqualTo("Tenant 1 Payee"));
        Assert.That(tenant2Transaction.Payee, Is.EqualTo("Tenant 2 Payee"));
    }

    [Test]
    public async Task Transaction_CanQueryByTenantIdAndExternalId()
    {
        // Given: Multiple transactions with different ExternalIds
        _context.Transactions.AddRange(
            new Transaction { Date = DateOnly.FromDateTime(DateTime.Now), Payee = "Payee 1", Amount = 100m, ExternalId = "EXT-001", TenantId = _tenant1.Id },
            new Transaction { Date = DateOnly.FromDateTime(DateTime.Now), Payee = "Payee 2", Amount = 200m, ExternalId = "EXT-002", TenantId = _tenant1.Id },
            new Transaction { Date = DateOnly.FromDateTime(DateTime.Now), Payee = "Payee 3", Amount = 300m, ExternalId = "EXT-001", TenantId = _tenant2.Id }
        );
        await _context.SaveChangesAsync();

        // When: Querying by TenantId and ExternalId (importer duplicate check pattern)
        var exists = await _context.Transactions
            .AnyAsync(t => t.TenantId == _tenant1.Id && t.ExternalId == "EXT-001");

        // Then: Should find the matching transaction
        Assert.That(exists, Is.True);

        // And: Composite index should make this query efficient
        var transaction = await _context.Transactions
            .FirstOrDefaultAsync(t => t.TenantId == _tenant1.Id && t.ExternalId == "EXT-001");
        Assert.That(transaction, Is.Not.Null);
        Assert.That(transaction!.Payee, Is.EqualTo("Payee 1"));
    }

    [Test]
    public async Task Transaction_CompositeIndexOnTenantIdExternalIdExists()
    {
        // Given: Database with Transaction table

        // When: Checking for the composite index
        var connection = _context.Database.GetDbConnection();
        await connection.OpenAsync();
        using var command = connection.CreateCommand();
        command.CommandText = @"
            SELECT name FROM sqlite_master
            WHERE type='index'
            AND tbl_name='YoFi.V3.Transactions'
            AND name LIKE '%TenantId_ExternalId%'";
        var indexName = await command.ExecuteScalarAsync();

        // Then: Composite index should exist
        Assert.That(indexName, Is.Not.Null);
        Assert.That(indexName!.ToString(), Does.Contain("TenantId_ExternalId"));
    }

    [Test]
    public async Task Transaction_MemoCanContainSpecialCharacters()
    {
        // Given: A transaction with memo containing special characters
        var specialMemo = "Test memo with special chars: !@#$%^&*()_+-=[]{}|;':\",./<>?";
        var transaction = new Transaction
        {
            Date = DateOnly.FromDateTime(DateTime.Now),
            Payee = "Test Payee",
            Amount = 100m,
            Memo = specialMemo,
            TenantId = _tenant1.Id
        };

        // When: Saving the transaction
        _context.Transactions.Add(transaction);
        await _context.SaveChangesAsync();

        // Then: Memo with special characters should be preserved
        var retrieved = await _context.Transactions.FindAsync(transaction.Id);
        Assert.That(retrieved, Is.Not.Null);
        Assert.That(retrieved!.Memo, Is.EqualTo(specialMemo));
    }

    [Test]
    public async Task Transaction_MemoCanContainMultilineText()
    {
        // Given: A transaction with multi-line memo
        var multilineMemo = "Line 1\nLine 2\nLine 3";
        var transaction = new Transaction
        {
            Date = DateOnly.FromDateTime(DateTime.Now),
            Payee = "Test Payee",
            Amount = 100m,
            Memo = multilineMemo,
            TenantId = _tenant1.Id
        };

        // When: Saving the transaction
        _context.Transactions.Add(transaction);
        await _context.SaveChangesAsync();

        // Then: Multi-line memo should be preserved
        var retrieved = await _context.Transactions.FindAsync(transaction.Id);
        Assert.That(retrieved, Is.Not.Null);
        Assert.That(retrieved!.Memo, Is.EqualTo(multilineMemo));
    }
}
