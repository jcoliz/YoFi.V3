# Project Rules for YoFi.V3

## Logging Pattern

**Always follow these logging conventions:**

1. **Use LoggerMessage attribute** - Never use direct logger calls like `_logger.LogInformation()`. Always use the `[LoggerMessage]` attribute with partial methods.

2. **CallerMemberName location pattern** - All log methods must include `[CallerMemberName] string? location = null` as the last parameter. The log message template should start with `{Location}:` to automatically capture the calling method name.

3. **Concise log messages** - Keep messages brief. The `{Location}` parameter usually provides sufficient context about where the log originated. Format: `"{Location}: Brief description {Parameter}"`

4. **Debug-level "Starting" messages** - Use `LogLevel.Debug` for "Starting" messages at the beginning of operations. Format: `"{Location}: Starting"` or `"{Location}: Starting {Key}"` if there's a parameter.

5. **Information-level "OK" messages** - Prefer an "OK" message as the final log message in a method upon success. Use `LogLevel.Information`. Format: `"{Location}: OK"` or `"{Location}: OK {Parameter}"`.

6. **One Information log per method** - Prefer only one Information-level log per method (typically the final "OK" message), unless there's a strong reason for multiple. Debug, Warning, and Error messages don't count toward this limit.

7. **Unique parameter signatures** - Only create a new logger message method if the parameter combination is unique. Reuse existing log methods when the parameters match, even if the calling location is different.

8. **Partial class requirement** - Classes using LoggerMessage must be declared as `partial class`.

9. **Primary constructor pattern** - Use primary constructor syntax for dependency injection: `public partial class MyClass(ILogger<MyClass> logger)`

10. **Required using statements**:
    - `using System.Runtime.CompilerServices;` (for CallerMemberName)
    - `using Microsoft.Extensions.Logging;` (for LoggerMessage)

### Example Pattern

```csharp
using System.Runtime.CompilerServices;
using Microsoft.Extensions.Logging;

public partial class MyController(ILogger<MyController> logger) : ControllerBase
{
    [HttpGet("{id}")]
    public async Task<IActionResult> GetById(Guid id)
    {
        LogStartingKey(id);

        var result = await GetData(id);

        LogOkKey(id);
        return Ok(result);
    }

    [LoggerMessage(0, LogLevel.Debug, "{Location}: Starting {Key}")]
    private partial void LogStartingKey(Guid key, [CallerMemberName] string? location = null);

    [LoggerMessage(1, LogLevel.Information, "{Location}: OK {Key}")]
    private partial void LogOkKey(Guid key, [CallerMemberName] string? location = null);
}
```

### Common Log Method Patterns

- `LogStarting()` - Debug level, no parameters
- `LogStartingKey(Guid key)` - Debug level, with key parameter
- `LogOk()` - Information level, no parameters
- `LogOkKey(Guid key)` - Information level, with key parameter
- `LogOkCount(int count)` - Information level, with count parameter
- `LogNotFound()` - Warning level, no parameters

## Test Documentation Pattern

**Always use Gherkin-style comments (Given/When/Then/And) to document test scenarios. DO NOT use the traditional Arrange/Act/Assert pattern.**

1. **Gherkin-style structure** - All tests (unit, integration, functional) must use Given/When/Then/And comments to describe the test flow.

2. **Comment format** - Each step should be a single-line comment starting with the Gherkin keyword followed by a colon and descriptive text:
   - `// Given:` - Describes the initial context or preconditions
   - `// When:` - Describes the action being tested
   - `// Then:` - Describes the expected outcome
   - `// And:` - Continues or adds to the previous step type

3. **Descriptive text** - Keep descriptions clear and focused on business/functional behavior rather than implementation details.

4. **Blank lines** - Use blank lines between Gherkin steps to improve readability.

### Example Pattern: Error Case with Invalid Input

```csharp
[Test]
public async Task GetTransactions_InvalidTenantIdFormat_Returns404WithProblemDetails()
{
    // Given: A request with an invalid tenant ID format (not a valid GUID)

    // When: API Client requests transactions with invalid tenant ID format
    var response = await _client.GetAsync("/api/tenant/1/transactions");

    // Then: 404 Not Found should be returned
    Assert.That(response.StatusCode, Is.EqualTo(HttpStatusCode.NotFound));

    // And: Response should contain problem details (not empty body)
    var content = await response.Content.ReadAsStringAsync();
    Assert.That(content, Is.Not.Empty, "Response body should not be empty");

    // And: Response should be valid problem details JSON
    var problemDetails = await response.Content.ReadFromJsonAsync<ProblemDetails>();
    Assert.That(problemDetails, Is.Not.Null, "Response should be deserializable as ProblemDetails");
    Assert.That(problemDetails!.Status, Is.EqualTo(404));
}
```

### Example Pattern: Success Case with Data Setup

```csharp
[Test]
public async Task CreateTransaction_ValidData_ReturnsCreatedTransaction()
{
    // Given: A valid tenant exists
    var tenantId = Guid.NewGuid();
    await SeedTenant(tenantId);

    // And: Valid transaction data is prepared
    var newTransaction = new TransactionEditDto
    {
        Date = DateTime.UtcNow,
        Payee = "Test Payee",
        Amount = 100.50m
    };

    // When: API Client creates a new transaction
    var response = await _client.PostAsJsonAsync($"/api/tenant/{tenantId}/transactions", newTransaction);

    // Then: 201 Created should be returned
    Assert.That(response.StatusCode, Is.EqualTo(HttpStatusCode.Created));

    // And: Response should contain the created transaction
    var created = await response.Content.ReadFromJsonAsync<TransactionResultDto>();
    Assert.That(created, Is.Not.Null);
    Assert.That(created!.Payee, Is.EqualTo("Test Payee"));
    Assert.That(created.Amount, Is.EqualTo(100.50m));
}
```

### Example Pattern: Unit Test with Multiple Assertions

```csharp
[Test]
public void ValidateTransaction_MissingRequiredFields_ReturnsValidationErrors()
{
    // Given: A transaction with missing required fields
    var transaction = new TransactionEditDto
    {
        Date = DateTime.UtcNow
        // Payee and Amount are missing
    };

    // When: Transaction is validated
    var validator = new TransactionValidator();
    var result = validator.Validate(transaction);

    // Then: Validation should fail
    Assert.That(result.IsValid, Is.False);

    // And: Should have errors for missing Payee
    Assert.That(result.Errors.Any(e => e.PropertyName == nameof(TransactionEditDto.Payee)), Is.True);

    // And: Should have errors for missing Amount
    Assert.That(result.Errors.Any(e => e.PropertyName == nameof(TransactionEditDto.Amount)), Is.True);
}
```

### Common Patterns

- **Given** - Use for setup, preconditions, test data creation
- **When** - Use for the single primary action being tested
- **Then** - Use for the primary expected outcome
- **And** - Use to chain multiple assertions or setups within the same category

### Benefits Over Arrange/Act/Assert

- More readable and business-focused
- Better describes the scenario being tested
- Aligns with behavior-driven development (BDD) practices
- Makes test intent clearer to non-technical stakeholders
- Natural progression through test flow

**Source Example:** See `tests/Integration.Controller/TransactionsControllerTests.cs` for reference implementation.

## Regex Pattern

**Use source-generated regexes in production code for better performance.**

1. **Source-generated regexes** - Use the `[GeneratedRegex]` attribute with partial methods to generate regex code at compile time:
   ```csharp
   using System.Text.RegularExpressions;

   public partial class MyClass
   {
       [GeneratedRegex(@"\d{4}-\d{2}-\d{2}")]
       private static partial Regex DatePattern();
   }
   ```

2. **Test code exception** - Regexes in test code (unit, integration, functional) don't require source generation for simplicity and readability. Use whichever pattern is most convenient.

3. **Performance rationale** - Source-generated regexes have zero runtime compilation cost and significantly better runtime performance for repeated use. Since production code regexes are typically reused many times, source generation is worthwhile.

### Benefits

- Zero runtime compilation cost, best performance
- Compile-time validation of regex patterns
- Generated code is optimized and cached for reuse

## Test Execution Pattern

**Always run tests after creating or modifying them to verify they pass (except functional tests).**

1. **Automatic test execution** - Whenever you add new tests or modify existing tests, you must run the relevant test suite to verify all tests pass before completing the task. This applies to unit tests, integration tests, but NOT functional tests (which require special setup).

2. **Fix failures immediately** - If tests fail, you must analyze the failure, fix the issue, and re-run the tests until they all pass. Do not wait for user direction to fix test failures.

3. **Test scope** - Run the specific test project that contains the modified tests:
   - For Integration.Data tests: `dotnet test tests/Integration.Data`
   - For Integration.Controller tests: `dotnet test tests/Integration.Controller`
   - For Unit tests: `dotnet test tests/Unit`
   - For Functional tests: DO NOT automatically run (requires special setup)

4. **Iterate until green** - Continue the fix-test-verify cycle until all tests pass successfully.

### Example Workflow

When adding new tests to `TenantRepositoryTests.cs`:
1. Create or modify the test methods
2. Run `dotnet test tests/Integration.Data`
3. If failures occur, analyze the error messages
4. Fix the issues in the test code or implementation
5. Re-run `dotnet test tests/Integration.Data`
6. Repeat steps 3-5 until all tests pass
7. Only then complete the task

This ensures code quality and prevents introducing broken tests into the codebase.

## Application Layer Change Pattern

**Always review and update unit tests when making changes to the Application layer.**

1. **Review unit tests** - Whenever you modify code in the `src/Application` project (features, services, DTOs, validation), you must check if corresponding unit tests in `tests/Unit` need to be updated.

2. **Maintain code coverage** - When adding new code to the Application layer, you must add comprehensive unit tests to maintain code coverage at or near 100%. Every new method, validation rule, or code path should have corresponding test coverage.

3. **Common scenarios requiring test updates**:
   - Changing method signatures (return types, parameters)
   - Adding or removing methods
   - Modifying validation logic
   - Changing DTOs or data structures
   - Altering business logic behavior

4. **Update and verify** - After updating unit tests:
   - Run the unit test suite to verify changes: `dotnet test tests/Unit`
   - Fix any failures before completing the task
   - Ensure test coverage remains comprehensive

### Example

When changing `AddTransactionAsync()` from `Task` to `Task<TransactionResultDto>`:
1. Identify affected tests (search for `AddTransactionAsync` in unit tests)
2. Update tests to capture and verify the return value
3. Add tests for any new code paths or validation rules
4. Run `dotnet test tests/Unit` to verify all tests pass
5. Only then mark the task as complete

This ensures unit tests accurately reflect the current Application layer implementation and maintain comprehensive test coverage.

## XML Documentation Comments Pattern

**Always add comprehensive XML documentation comments to all new code.**

1. **Always add class comments** - When creating new classes, always include XML documentation with a `<summary>` and, when appropriate, a `<remarks>` section.

2. **Primary constructor parameters** - For classes using primary constructor syntax, include `<param>` tags directly on the class documentation to describe each constructor parameter.

3. **Method documentation** - Document all public and internal methods with at minimum a `<summary>`. Include `<param>` tags for all parameters.

4. **Returns documentation** - Do NOT include `<returns>` tags when a method returns ONLY `Task` or ONLY `Task<IActionResult>`. For other return types, document them with a `<returns>` tag.

5. **Exception documentation** - Always document exceptions that are thrown directly by the method using `<exception>` tags.

6. **Record types and DTOs** - All record types must have class-level XML comments. For records that declare properties in the primary constructor, the properties themselves do not need separate comments.

7. **Standard parameter descriptions** - Use standard descriptions for common parameters:
   - Logger parameters: "Logger for diagnostic output"
   - Repository parameters: "Repository for [entity] data operations"
   - Feature parameters: "Feature providing [capability] operations"

8. **Private methods** - LoggerMessage methods do not need comments. Other private methods should be documented if they are doing anything non-obvious.

9. **"Create class comments" directive** - When asked to "create class comments" for a file, this means provide comprehensive documentation including:
   - Class-level XML comments (with `<summary>`, `<remarks>`, and `<param>` for primary constructors)
   - Method-level XML comments for ALL public and internal methods (with `<summary>`, `<param>`, `<returns>` where appropriate, and `<exception>` tags)
   - This is NOT just adding comments to the class declaration itself, but full in-depth documentation as described in this pattern

### Example: Class with Primary Constructor

```csharp
/// <summary>
/// Manages tenant operations for the current authenticated user.
/// </summary>
/// <param name="tenantFeature">Feature providing tenant management operations.</param>
/// <param name="logger">Logger for diagnostic output.</param>
/// <remarks>
/// This controller provides endpoints for users to view and manage their tenant memberships.
/// All operations are scoped to the currently authenticated user.
/// </remarks>
public partial class TenantController(TenantFeature tenantFeature, ILogger<TenantController> logger) : ControllerBase
{
    /// <summary>
    /// Retrieves all tenants associated with the current authenticated user.
    /// </summary>
    public async Task<IActionResult> GetTenants()
    {
        // Implementation
    }

    /// <summary>
    /// Retrieves a specific tenant by its unique key.
    /// </summary>
    /// <param name="key">The unique identifier of the tenant.</param>
    /// <exception cref="KeyNotFoundException">Thrown when the tenant is not found or user lacks access.</exception>
    public async Task<IActionResult> GetTenant(Guid key)
    {
        // Implementation
    }
}
```

### Example: Record Type

```csharp
/// <summary>
/// Data transfer object for creating or editing a tenant.
/// </summary>
/// <param name="Name">The name of the tenant.</param>
/// <param name="Description">A description of the tenant.</param>
public record TenantEditDto(string Name, string Description);
```

### Example: Method with Return Value

```csharp
/// <summary>
/// Creates a new tenant and assigns the specified user as the owner.
/// </summary>
/// <param name="userId">The unique identifier of the user who will be the tenant owner.</param>
/// <param name="tenantDto">The tenant data including name and description.</param>
/// <returns>A <see cref="TenantResultDto"/> containing the created tenant's information.</returns>
public async Task<TenantResultDto> CreateTenantForUserAsync(Guid userId, TenantEditDto tenantDto)
{
    // Implementation
}
```

**Note:** The `[ProducesResponseType]` attributes on controller methods provide sufficient documentation for HTTP response codes, so no additional `<remarks>` are needed to describe them.
