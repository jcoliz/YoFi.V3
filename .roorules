# Project Rules for YoFi.V3

## Project Structure

**Understanding the codebase layout for efficient navigation and development.**

### Directory Organization

```
YoFi.V3/
├── src/                          # All source code
│   ├── FrontEnd.Nuxt/           # Frontend Vue/Nuxt application
│   │   ├── app/                 # Nuxt app directory
│   │   │   ├── pages/          # Vue pages (login.vue, register.vue, transactions.vue, etc.)
│   │   │   ├── components/     # Reusable Vue components
│   │   │   ├── composables/    # Vue composables
│   │   │   ├── utils/          # Frontend utilities (apiclient.ts, errorHandler.ts)
│   │   │   └── stores/         # Pinia stores
│   │   ├── .roorules           # Frontend-specific Roo rules
│   │   ├── nuxt.config.ts      # Nuxt configuration
│   │   └── package.json        # Frontend dependencies
│   │
│   ├── BackEnd/                 # ASP.NET Core backend API
│   ├── Controllers/             # API Controllers layer
│   ├── Application/             # Application Features layer
│   ├── Entities/                # Domain entities and exceptions
│   ├── WireApiHost/            # NSwag API client generation
│   └── ServiceDefaults/        # Shared service configuration
│
├── tests/                       # All test projects
│   ├── Functional/             # End-to-end Playwright tests
│   │   ├── Pages/              # Page Object Models
│   │   ├── Features/           # Gherkin feature files
│   │   └── Steps/              # Step definitions
│   ├── Integration.Controller/ # Controller integration tests
│   ├── Integration.Data/       # Data layer integration tests
│   └── Unit/                   # Unit tests
│
├── docs/                        # Documentation
│   ├── wip/                    # Work-in-progress documents
│   └── adr/                    # Architecture Decision Records
│
├── scripts/                     # PowerShell automation scripts
│   ├── Run-Tests.ps1           # Run backend tests
│   ├── Run-FunctionalTestsVsContainer.ps1  # Run functional tests
│   ├── Start-LocalDev.ps1      # Start local development
│   └── Edit-FrontEnd.ps1       # Navigate to frontend
│
├── docker/                      # Docker configurations
├── infra/                       # Infrastructure as Code (Bicep)
└── submodules/                  # Git submodules (NuxtIdentity)
```

### Key Locations

**Frontend Development:**
- **Location**: `src/FrontEnd.Nuxt/`
- **Vue Pages**: `src/FrontEnd.Nuxt/app/pages/` - login.vue, register.vue, transactions.vue, workspaces.vue
- **Vue Components**: `src/FrontEnd.Nuxt/app/components/` - Reusable components like ModalDialog.vue, ErrorDisplay.vue
- **API Client**: `src/FrontEnd.Nuxt/app/utils/apiclient.ts` - Auto-generated, DO NOT edit manually
- **Frontend Rules**: `src/FrontEnd.Nuxt/.roorules` - Frontend-specific patterns and testing guidelines

**Backend Development:**
- **Controllers**: `src/Controllers/` - API endpoints
- **Features**: `src/Application/` - Business logic
- **Tests**: `tests/Unit/`, `tests/Integration.Controller/`, `tests/Integration.Data/`

**Functional Tests:**
- **Location**: `tests/Functional/`
- **Page Objects**: `tests/Functional/Pages/` - LoginPage.cs, TransactionsPage.cs, etc.
- **Feature Files**: `tests/Functional/Features/` - Gherkin scenarios
- **Requirements**: `tests/Functional/FRONTEND-CHANGES-REQUIRED.md` - Frontend test requirements

### Navigation Tips

1. **Finding Frontend Code**: Always look in `src/FrontEnd.Nuxt/app/` directory
   - Pages: `app/pages/*.vue`
   - Components: `app/components/*.vue`
   - Utilities: `app/utils/*.ts`

2. **Finding Backend Code**: Look in `src/` subdirectories
   - API: `src/Controllers/`
   - Logic: `src/Application/`
   - Data: Entity Framework configurations are in respective project contexts

3. **Finding Tests**: Look in `tests/` subdirectories
   - Frontend tests: `tests/Functional/`
   - Backend tests: `tests/Unit/`, `tests/Integration.*/`

4. **Quick Start Scripts**:
   - Edit frontend: `.\scripts\Edit-FrontEnd.ps1`
   - Run backend tests: `.\scripts\Run-Tests.ps1`
   - Run functional tests: `.\scripts\Run-FunctionalTestsVsContainer.ps1`

### Common Confusion Points

❌ **Don't look for frontend in**:
- `submodules/NuxtIdentity/` - This is a separate library project
- Root directory - No Vue files at root level
- `src/` root - Frontend is specifically in `src/FrontEnd.Nuxt/`

✅ **Always find frontend in**:
- `src/FrontEnd.Nuxt/app/` - All Vue application code

## Testing Framework Pattern

**Always use NUnit for all testing recommendations and examples.**

1. **NUnit is the standard** - This project uses NUnit as its testing framework. All test recommendations, examples, and new test projects must use NUnit, NOT xUnit or MSTest.

2. **Test attributes** - Use NUnit attributes:
   - `[Test]` for test methods
   - `[TestFixture]` for test classes
   - `[SetUp]` and `[TearDown]` for test lifecycle
   - `[OneTimeSetUp]` and `[OneTimeTearDown]` for fixture lifecycle
   - `[TestCase]` for parameterized tests
   - `[Explicit]` for tests that should not run by default

3. **Assertions** - Use NUnit's constraint-based assertion syntax:
   ```csharp
   Assert.That(actual, Is.EqualTo(expected));
   Assert.That(collection, Is.Not.Empty);
   Assert.That(result, Is.Null);
   ```

4. **Creating new test projects** - When recommending creation of new test projects, use:
   ```bash
   dotnet new nunit -n ProjectName
   ```
   NOT `dotnet new xunit` or `dotnet new mstest`.

5. **Package references** - New test projects should reference:
   - `NUnit` (test framework)
   - `NUnit3TestAdapter` (test adapter for test runners)
   - `Microsoft.NET.Test.Sdk` (test platform)

### Example: NUnit Test Structure

```csharp
using NUnit.Framework;

[TestFixture]
public class MyServiceTests
{
    private MyService _service;

    [SetUp]
    public void SetUp()
    {
        _service = new MyService();
    }

    [Test]
    public void MyMethod_ValidInput_ReturnsExpectedResult()
    {
        // Given: Valid input data
        var input = "test";

        // When: Method is called
        var result = _service.MyMethod(input);

        // Then: Expected result is returned
        Assert.That(result, Is.EqualTo("TEST"));
    }

    [TestCase("hello", "HELLO")]
    [TestCase("world", "WORLD")]
    public void MyMethod_VariousInputs_ReturnsUpperCase(string input, string expected)
    {
        var result = _service.MyMethod(input);
        Assert.That(result, Is.EqualTo(expected));
    }
}
```

## Logging Pattern

**Always follow these logging conventions. See [`docs/LOGGING-POLICY.md`](docs/LOGGING-POLICY.md) for complete policy.**

1. **Use LoggerMessage attribute** - Never use direct logger calls like `_logger.LogInformation()`. Always use the `[LoggerMessage]` attribute with partial methods.

2. **Explicit event IDs** - All logger message methods MUST include an explicit event ID as the first parameter to `[LoggerMessage]`:
   - Event IDs must be numeric integers in the range 1-9999 (1-4 digits)
   - Event IDs must be unique within each logging category (class)
   - Event IDs should be assigned sequentially starting from 1 within each class
   - Event IDs are forever tied to their logger method name and should NEVER be reused for a different method, even if the original method is removed
   - When adding new log methods, always use the next available number (highest existing ID + 1)
   - If the highest-numbered method is removed and no new method is added, simply leave that number unused

3. **CallerMemberName location pattern** - All log methods must include `[CallerMemberName] string? location = null` as the last parameter. The log message template should start with `{Location}:` to automatically capture the calling method name.

4. **Concise log messages** - Keep messages brief. The `{Location}` parameter usually provides sufficient context about where the log originated. Format: `"{Location}: Brief description {Parameter}"`

5. **Debug-level "Starting" messages** - Use `LogLevel.Debug` for "Starting" messages at the beginning of operations. Format: `"{Location}: Starting"` or `"{Location}: Starting {Key}"` if there's a parameter.

6. **Information-level "OK" messages** - Prefer an "OK" message as the final log message in a method upon success. Use `LogLevel.Information`. Format: `"{Location}: OK"` or `"{Location}: OK {Parameter}"`.

7. **One Information log per method** - Prefer only one Information-level log per method (typically the final "OK" message), unless there's a strong reason for multiple. Debug, Warning, and Error messages don't count toward this limit.

8. **Unique parameter signatures** - Only create a new logger message method if the parameter combination is unique. Reuse existing log methods when the parameters match, even if the calling location is different.

9. **Partial class requirement** - Classes using LoggerMessage must be declared as `partial class`.

10. **Primary constructor pattern** - Use primary constructor syntax for dependency injection: `public partial class MyClass(ILogger<MyClass> logger)`

11. **Required using statements**:
    - `using System.Runtime.CompilerServices;` (for CallerMemberName)
    - `using Microsoft.Extensions.Logging;` (for LoggerMessage)

12. **API-layer logging only** - Log at Controllers (API boundary) only. Application Features and Data Repositories should remain logging-free to maintain Clean Architecture principles. Add logging to lower layers only for specific scenarios (long-running operations, external service calls, complex workflows).

13. **Sensitive data rules** - NEVER log: email addresses, passwords, JWT tokens, refresh tokens (except first 8 chars in dev/container), tenant names, transaction amounts, payee names. CAN log: User GUIDs, Tenant GUIDs, TraceIds/SpanIds. Users provide TraceId or GUID when reporting issues.

14. **Logging scope for context** - Push UserId and TenantId to logging scope via middleware/filters when available. This makes them available in structured logging (Application Insights). However, if you want UserId or TenantId to appear in the console/container log MESSAGE itself (not just as structured properties), you must still include them as parameters in the log method and message template (e.g., `"{Location}: OK {TenantId}"`).

### Example Pattern

```csharp
using System.Runtime.CompilerServices;
using Microsoft.Extensions.Logging;

public partial class MyController(ILogger<MyController> logger) : ControllerBase
{
    [HttpGet("{id}")]
    public async Task<IActionResult> GetById(Guid id)
    {
        LogStartingKey(id);

        var result = await GetData(id);

        LogOkKey(id);
        return Ok(result);
    }

    [LoggerMessage(1, LogLevel.Debug, "{Location}: Starting {Key}")]
    private partial void LogStartingKey(Guid key, [CallerMemberName] string? location = null);

    [LoggerMessage(2, LogLevel.Information, "{Location}: OK {Key}")]
    private partial void LogOkKey(Guid key, [CallerMemberName] string? location = null);
}
```

### Event ID Assignment Example

When evolving a class over time, event IDs remain stable:

```csharp
// Initial version - IDs 1, 2, 3
[LoggerMessage(1, LogLevel.Debug, "{Location}: Starting")]
private partial void LogStarting([CallerMemberName] string? location = null);

[LoggerMessage(2, LogLevel.Debug, "{Location}: Starting {Email}")]
private partial void LogStartingEmail(string email, [CallerMemberName] string? location = null);

[LoggerMessage(3, LogLevel.Debug, "{Location}: Starting {Key}")]
private partial void LogStartingKey(Guid key, [CallerMemberName] string? location = null);

// Later: Replace LogStartingEmail with LogStartingUsername
// ID 2 is retired (never reuse it), and we assign ID 4 to the new method
[LoggerMessage(1, LogLevel.Debug, "{Location}: Starting")]
private partial void LogStarting([CallerMemberName] string? location = null);

// ID 2 - RETIRED (was LogStartingEmail) - do not reuse

[LoggerMessage(3, LogLevel.Debug, "{Location}: Starting {Key}")]
private partial void LogStartingKey(Guid key, [CallerMemberName] string? location = null);

[LoggerMessage(4, LogLevel.Debug, "{Location}: Starting {Username}")]
private partial void LogStartingUsername(string username, [CallerMemberName] string? location = null);

// Next new method would use ID 5
```

**Key principle:** Event IDs are permanent markers that provide stable references for log analysis, alerting, and monitoring. Never renumber existing IDs or reuse retired ones.

### Common Log Method Patterns

- `LogStarting()` - Debug level, no parameters
- `LogStartingKey(Guid key)` - Debug level, with key parameter
- `LogOk()` - Information level, no parameters
- `LogOkKey(Guid key)` - Information level, with key parameter
- `LogOkCount(int count)` - Information level, with count parameter
- `LogNotFound()` - Warning level, no parameters

### Test Controller Pattern

**For test controllers (like TestControlController), use the `ProblemWithLog()` helper method to ensure all ProblemDetails returns are automatically logged.**

Test controllers require comprehensive logging for all error conditions to aid functional test debugging. To ensure every `Problem()` return generates a log entry:

1. **Add ProblemWithLog() helper method** - Create a private helper method that logs and returns ProblemDetails atomically:
   ```csharp
   /// <summary>
   /// Returns a ProblemDetails response with automatic logging.
   /// </summary>
   /// <param name="statusCode">HTTP status code (e.g., StatusCodes.Status404NotFound)</param>
   /// <param name="title">Brief error title</param>
   /// <param name="detail">Detailed error message (optional)</param>
   /// <returns>ObjectResult containing ProblemDetails with logging side effect</returns>
   /// <remarks>
   /// Automatically logs at Warning level for 4xx errors and Error level for 5xx errors.
   /// Use this method instead of Problem() to ensure all error responses are logged.
   /// </remarks>
   private ObjectResult ProblemWithLog(
       int statusCode,
       string title,
       string? detail = null,
       [CallerMemberName] string? location = null)
   {
       if (statusCode >= 500)
       {
           LogProblemError(statusCode, title, detail ?? string.Empty);
       }
       else if (statusCode >= 400)
       {
           LogProblemWarning(statusCode, title, detail ?? string.Empty);
       }

       return Problem(title: title, detail: detail, statusCode: statusCode);
   }
   ```

2. **Add corresponding LoggerMessage methods**:
   ```csharp
   [LoggerMessage(10, LogLevel.Warning, "{Location}: Problem {StatusCode} - {Title}: {Detail}")]
   private partial void LogProblemWarning(int statusCode, string title, string detail, [CallerMemberName] string? location = null);

   [LoggerMessage(11, LogLevel.Error, "{Location}: Problem {StatusCode} - {Title}: {Detail}")]
   private partial void LogProblemError(int statusCode, string title, string detail, [CallerMemberName] string? location = null);
   ```

3. **Use ProblemWithLog() instead of Problem()**:
   ```csharp
   // Before
   return Problem(
       title: "User not found",
       detail: $"Test user '{username}' not found",
       statusCode: StatusCodes.Status404NotFound
   );

   // After
   return ProblemWithLog(
       StatusCodes.Status404NotFound,
       "User not found",
       $"Test user '{username}' not found"
   );
   ```

**Benefits:**
- Atomic operation - impossible to forget logging (compile-time guarantee)
- Automatic log level selection based on status code
- CallerMemberName captures calling method automatically
- All test control error responses are logged for functional test debugging

**Reference:** See [`src/Controllers/TestControlController.cs`](src/Controllers/TestControlController.cs) for production implementation.

## Test Documentation Pattern

**Always use Gherkin-style comments (Given/When/Then/And) to document test scenarios. DO NOT use the traditional Arrange/Act/Assert pattern.**

1. **Gherkin-style structure** - All tests (unit, integration, functional) must use Given/When/Then/And comments to describe the test flow.

2. **Comment format** - Each step should be a single-line comment starting with the Gherkin keyword followed by a colon and descriptive text:
   - `// Given:` - Describes the initial context or preconditions
   - `// When:` - Describes the action being tested
   - `// Then:` - Describes the expected outcome
   - `// And:` - Continues or adds to the previous step type

3. **Descriptive text** - Keep descriptions clear and focused on business/functional behavior rather than implementation details.

4. **Blank lines** - Use blank lines between Gherkin steps to improve readability.

### Example Pattern: Error Case with Invalid Input

```csharp
[Test]
public async Task GetTransactions_InvalidTenantIdFormat_Returns404WithProblemDetails()
{
    // Given: A request with an invalid tenant ID format (not a valid GUID)

    // When: API Client requests transactions with invalid tenant ID format
    var response = await _client.GetAsync("/api/tenant/1/transactions");

    // Then: 404 Not Found should be returned
    Assert.That(response.StatusCode, Is.EqualTo(HttpStatusCode.NotFound));

    // And: Response should contain problem details (not empty body)
    var content = await response.Content.ReadAsStringAsync();
    Assert.That(content, Is.Not.Empty, "Response body should not be empty");

    // And: Response should be valid problem details JSON
    var problemDetails = await response.Content.ReadFromJsonAsync<ProblemDetails>();
    Assert.That(problemDetails, Is.Not.Null, "Response should be deserializable as ProblemDetails");
    Assert.That(problemDetails!.Status, Is.EqualTo(404));
}
```

### Example Pattern: Success Case with Data Setup

```csharp
[Test]
public async Task CreateTransaction_ValidData_ReturnsCreatedTransaction()
{
    // Given: A valid tenant exists
    var tenantId = Guid.NewGuid();
    await SeedTenant(tenantId);

    // And: Valid transaction data is prepared
    var newTransaction = new TransactionEditDto
    {
        Date = DateTime.UtcNow,
        Payee = "Test Payee",
        Amount = 100.50m
    };

    // When: API Client creates a new transaction
    var response = await _client.PostAsJsonAsync($"/api/tenant/{tenantId}/transactions", newTransaction);

    // Then: 201 Created should be returned
    Assert.That(response.StatusCode, Is.EqualTo(HttpStatusCode.Created));

    // And: Response should contain the created transaction
    var created = await response.Content.ReadFromJsonAsync<TransactionResultDto>();
    Assert.That(created, Is.Not.Null);
    Assert.That(created!.Payee, Is.EqualTo("Test Payee"));
    Assert.That(created.Amount, Is.EqualTo(100.50m));
}
```

### Example Pattern: Unit Test with Multiple Assertions

```csharp
[Test]
public void ValidateTransaction_MissingRequiredFields_ReturnsValidationErrors()
{
    // Given: A transaction with missing required fields
    var transaction = new TransactionEditDto
    {
        Date = DateTime.UtcNow
        // Payee and Amount are missing
    };

    // When: Transaction is validated
    var validator = new TransactionValidator();
    var result = validator.Validate(transaction);

    // Then: Validation should fail
    Assert.That(result.IsValid, Is.False);

    // And: Should have errors for missing Payee
    Assert.That(result.Errors.Any(e => e.PropertyName == nameof(TransactionEditDto.Payee)), Is.True);

    // And: Should have errors for missing Amount
    Assert.That(result.Errors.Any(e => e.PropertyName == nameof(TransactionEditDto.Amount)), Is.True);
}
```

### Common Patterns

- **Given** - Use for setup, preconditions, test data creation
- **When** - Use for the single primary action being tested
- **Then** - Use for the primary expected outcome
- **And** - Use to chain multiple assertions or setups within the same category

### Benefits Over Arrange/Act/Assert

- More readable and business-focused
- Better describes the scenario being tested
- Aligns with behavior-driven development (BDD) practices
- Makes test intent clearer to non-technical stakeholders
- Natural progression through test flow

**Source Example:** See `tests/Integration.Controller/TransactionsControllerTests.cs` for reference implementation.

## Regex Pattern

**Use source-generated regexes in production code for better performance.**

1. **Source-generated regexes** - Use the `[GeneratedRegex]` attribute with partial methods to generate regex code at compile time:
   ```csharp
   using System.Text.RegularExpressions;

   public partial class MyClass
   {
       [GeneratedRegex(@"\d{4}-\d{2}-\d{2}")]
       private static partial Regex DatePattern();
   }
   ```

2. **Test code exception** - Regexes in test code (unit, integration, functional) don't require source generation for simplicity and readability. Use whichever pattern is most convenient.

3. **Performance rationale** - Source-generated regexes have zero runtime compilation cost and significantly better runtime performance for repeated use. Since production code regexes are typically reused many times, source generation is worthwhile.

### Benefits

- Zero runtime compilation cost, best performance
- Compile-time validation of regex patterns
- Generated code is optimized and cached for reuse

## Test Execution Pattern

**Always run tests after creating or modifying them to verify they pass (except functional tests).**

1. **Automatic test execution** - Whenever you add new tests or modify existing tests, you must run the relevant test suite to verify all tests pass before completing the task. This applies to unit tests, integration tests, but NOT functional tests (which require special setup).

2. **Fix failures immediately** - If tests fail, you must analyze the failure, fix the issue, and re-run the tests until they all pass. Do not wait for user direction to fix test failures.

3. **Use project scripts for testing** - Always use `./scripts/Run-Tests.ps1` to run tests. DO NOT use `dotnet test` directly on the solution root, as it will include functional tests that require special setup.
   - For all unit and integration tests: `pwsh -File ./scripts/Run-Tests.ps1`
   - For specific test projects (when needed): `dotnet test tests/Unit`, `dotnet test tests/Integration.Data`, or `dotnet test tests/Integration.Controller`
   - For Functional tests: NEVER run automatically. Instead, ask the user to run `./scripts/Run-FunctionalTestsVsContainer.ps1` and report back the results.

4. **Iterate until green** - Continue the fix-test-verify cycle until all tests pass successfully.

5. **Explicit attribute for intentionally skipped tests** - Use the `[Explicit]` attribute (NOT `[Ignore]`) for tests that should not run by default but can be run manually. Include a clear reason string explaining why the test is explicit. Common reasons include:
   - Tests requiring special infrastructure setup
   - Tests that depend on external services
   - Tests that require manual verification
   - Tests that expose limitations in the test infrastructure

   Example:
   ```csharp
   [Test]
   [Explicit("Requires test infrastructure enhancement to support truly unauthenticated requests.")]
   public async Task GetResource_Unauthenticated_Returns401()
   {
       // Test implementation
   }
   ```

### Example Workflow

When adding new tests to `TenantRepositoryTests.cs`:
1. Create or modify the test methods
2. Run `pwsh -File ./scripts/Run-Tests.ps1` (for all tests) OR `dotnet test tests/Integration.Data` (for specific project)
3. If failures occur, analyze the error messages
4. Fix the issues in the test code or implementation
5. Re-run the test command
6. Repeat steps 3-5 until all tests pass
7. Only then complete the task

This ensures code quality and prevents introducing broken tests into the codebase.

## Application Layer Change Pattern

**Always review and update unit tests when making changes to the Application layer.**

1. **Review unit tests** - Whenever you modify code in the `src/Application` project (features, services, DTOs, validation), you must check if corresponding unit tests in `tests/Unit` need to be updated.

2. **Maintain code coverage** - When adding new code to the Application layer, you must add comprehensive unit tests to maintain code coverage at or near 100%. Every new method, validation rule, or code path should have corresponding test coverage.

3. **Common scenarios requiring test updates**:
   - Changing method signatures (return types, parameters)
   - Adding or removing methods
   - Modifying validation logic
   - Changing DTOs or data structures
   - Altering business logic behavior

4. **Update and verify** - After updating unit tests:
   - Run the unit test suite to verify changes: `dotnet test tests/Unit`
   - Fix any failures before completing the task
   - Ensure test coverage remains comprehensive

### Example

When changing `AddTransactionAsync()` from `Task` to `Task<TransactionResultDto>`:
1. Identify affected tests (search for `AddTransactionAsync` in unit tests)
2. Update tests to capture and verify the return value
3. Add tests for any new code paths or validation rules
4. Run `dotnet test tests/Unit` to verify all tests pass
5. Only then mark the task as complete

This ensures unit tests accurately reflect the current Application layer implementation and maintain comprehensive test coverage.

## XML Documentation Comments Pattern

**Always add comprehensive XML documentation comments to all new code.**

1. **Always add class comments** - When creating new classes, always include XML documentation with a `<summary>` and, when appropriate, a `<remarks>` section.

2. **Primary constructor parameters** - For classes using primary constructor syntax, include `<param>` tags directly on the class documentation to describe each constructor parameter.

3. **Method documentation** - Document all public and internal methods with at minimum a `<summary>`. Include `<param>` tags for all parameters.

4. **Test method exception** - Individual test methods in test fixture classes (methods with `[Test]` attribute) do NOT require XML documentation comments. The test method names and Given/When/Then comments provide sufficient documentation. However, test fixture classes themselves still require class-level documentation, and test helper classes and methods still require full XML documentation.

5. **Returns documentation** - Do NOT include `<returns>` tags when a method returns ONLY `Task` or ONLY `Task<IActionResult>`. For other return types, document them with a `<returns>` tag.

6. **Exception documentation** - Always document exceptions that are thrown directly by the method using `<exception>` tags.

7. **Record types and DTOs** - All record types must have class-level XML comments. For records that declare properties in the primary constructor, the properties themselves do not need separate comments.

8. **Standard parameter descriptions** - Use standard descriptions for common parameters:
   - Logger parameters: "Logger for diagnostic output"
   - Repository parameters: "Repository for [entity] data operations"
   - Feature parameters: "Feature providing [capability] operations"

9. **Private methods** - LoggerMessage methods do not need comments. Other private methods should be documented if they are doing anything non-obvious.

10. **"Create class comments" directive** - When asked to "create class comments" for a file, this means provide comprehensive documentation including:
   - Class-level XML comments (with `<summary>`, `<remarks>`, and `<param>` for primary constructors)
   - Method-level XML comments for ALL public and internal methods (with `<summary>`, `<param>`, `<returns>` where appropriate, and `<exception>` tags)
   - This is NOT just adding comments to the class declaration itself, but full in-depth documentation as described in this pattern

### Example: Class with Primary Constructor

```csharp
/// <summary>
/// Manages tenant operations for the current authenticated user.
/// </summary>
/// <param name="tenantFeature">Feature providing tenant management operations.</param>
/// <param name="logger">Logger for diagnostic output.</param>
/// <remarks>
/// This controller provides endpoints for users to view and manage their tenant memberships.
/// All operations are scoped to the currently authenticated user.
/// </remarks>
public partial class TenantController(TenantFeature tenantFeature, ILogger<TenantController> logger) : ControllerBase
{
    /// <summary>
    /// Retrieves all tenants associated with the current authenticated user.
    /// </summary>
    public async Task<IActionResult> GetTenants()
    {
        // Implementation
    }

    /// <summary>
    /// Retrieves a specific tenant by its unique key.
    /// </summary>
    /// <param name="key">The unique identifier of the tenant.</param>
    /// <exception cref="KeyNotFoundException">Thrown when the tenant is not found or user lacks access.</exception>
    public async Task<IActionResult> GetTenant(Guid key)
    {
        // Implementation
    }
}
```

### Example: Record Type

```csharp
/// <summary>
/// Data transfer object for creating or editing a tenant.
/// </summary>
/// <param name="Name">The name of the tenant.</param>
/// <param name="Description">A description of the tenant.</param>
public record TenantEditDto(string Name, string Description);
```

### Example: Method with Return Value

```csharp
/// <summary>
/// Creates a new tenant and assigns the specified user as the owner.
/// </summary>
/// <param name="userId">The unique identifier of the user who will be the tenant owner.</param>
/// <param name="tenantDto">The tenant data including name and description.</param>
/// <returns>A <see cref="TenantResultDto"/> containing the created tenant's information.</returns>
public async Task<TenantResultDto> CreateTenantForUserAsync(Guid userId, TenantEditDto tenantDto)
{
    // Implementation
}
```

**Note:** The `[ProducesResponseType]` attributes on controller methods provide sufficient documentation for HTTP response codes, so no additional `<remarks>` are needed to describe them.

## PowerShell Script Pattern

**Follow these conventions when creating PowerShell scripts for this project.**

1. **Comment-Based Help** - All scripts must include comprehensive comment-based help at the top with the following sections:
   - `.SYNOPSIS` - Brief one-line description of what the script does
   - `.DESCRIPTION` - Detailed explanation of the script's functionality and purpose
   - `.PARAMETER` - Document each parameter with its purpose (if the script has parameters)
   - `.EXAMPLE` - Provide at least one usage example; include multiple examples for complex scripts
   - `.NOTES` - Include any prerequisites, dependencies, or important information
   - `.LINK` - Include relevant documentation links (optional but recommended)

2. **CmdletBinding** - Always use `[CmdletBinding()]` to enable cmdlet features and better error handling.

3. **Parameter Validation** - Use PowerShell validation attributes for parameters:
   - `[ValidateSet()]` for enumerated values
   - `[Parameter()]` to mark parameters as required or optional
   - Provide sensible defaults where appropriate

4. **Error Handling** - Set `$ErrorActionPreference = "Stop"` at the script start and wrap main logic in try/catch/finally:
   ```powershell
   $ErrorActionPreference = "Stop"

   try {
       # Main script logic
   }
   catch {
       Write-Error "Failed to [action]: $_"
       Write-Error $_.ScriptStackTrace
       exit 1
   }
   finally {
       # Cleanup (e.g., Pop-Location)
   }
   ```

5. **PSScriptRoot for Path Resolution** - Always use `$PSScriptRoot` for path resolution to allow scripts to run from any directory:
   - Use `$PSScriptRoot/..` to reference the repository root
   - Use `$PSScriptRoot/../src` to reference source files
   - Use `$PSScriptRoot/../tests` to reference test files
   - Store the repository root in a variable if used multiple times: `$repoRoot = Split-Path $PSScriptRoot -Parent`

6. **Location Management** - Use `Push-Location`/`Pop-Location` for directory changes:
   - Always use `try/finally` to ensure `Pop-Location` is called even on errors
   - Prefer `Push-Location` over `cd` or `Set-Location` for proper cleanup

7. **Colored Output** - Use Write-Host with colors for better user experience:
   - **Cyan** (`-ForegroundColor Cyan`) - For informational messages and section headers
   - **Green** (`-ForegroundColor Green`) - For success messages (e.g., "OK Build succeeded")
   - **Yellow** (`-ForegroundColor Yellow`) - For warnings (e.g., "WARNING Some tests failed")
   - **Red** (`-ForegroundColor Red`) - For errors (only via Write-Error, which is already red)

8. **Exit Code Handling** - Check `$LASTEXITCODE` after external commands and throw errors on failure:
   ```powershell
   dotnet build
   if ($LASTEXITCODE -ne 0) {
       throw "Build failed with exit code $LASTEXITCODE"
   }
   ```

9. **Naming Convention** - Use PascalCase with verb-noun format for script names:
   - Use approved PowerShell verbs: Get-, Set-, New-, Remove-, Start-, Stop-, Build-, Run-, etc.
   - Examples: `Build-Container.ps1`, `Run-Tests.ps1`, `Start-LocalDev.ps1`

10. **Helper Functions** - Define reusable helper functions within scripts when needed:
    - Use PascalCase for function names with verb-noun format
    - Place helper functions before the main script logic
    - Document functions with comment-based help if they're complex

11. **Script Organization** - Structure scripts in this order:
    1. Comment-based help block
    2. `[CmdletBinding()]` and parameters
    3. `$ErrorActionPreference = "Stop"`
    4. Helper functions (if any)
    5. Main logic in try/catch/finally

12. **Update README** - When creating a new script, always add it to the [`scripts/README.md`](scripts/README.md) with a description of what it does and how to use it.

### Example: Minimal Script Pattern

```powershell
<#
.SYNOPSIS
Builds the solution and runs unit tests.

.DESCRIPTION
This script performs a clean build of the solution and executes all unit tests
to verify code quality. It's useful for quick verification during development.

.EXAMPLE
.\Build-AndTest.ps1
Builds the solution and runs all unit tests.

.NOTES
Requires .NET SDK to be installed and available in PATH.
#>

[CmdletBinding()]
param()

$ErrorActionPreference = "Stop"

try {
    $repoRoot = Split-Path $PSScriptRoot -Parent
    Push-Location $repoRoot

    Write-Host "Building solution..." -ForegroundColor Cyan
    dotnet build
    if ($LASTEXITCODE -ne 0) {
        throw "Build failed with exit code $LASTEXITCODE"
    }
    Write-Host "OK Build succeeded" -ForegroundColor Green

    Write-Host "Running unit tests..." -ForegroundColor Cyan
    dotnet test tests/Unit --no-build
    if ($LASTEXITCODE -ne 0) {
        throw "Tests failed with exit code $LASTEXITCODE"
    }
    Write-Host "OK All tests passed" -ForegroundColor Green
}
catch {
    Write-Error "Failed to build and test: $_"
    Write-Error $_.ScriptStackTrace
    exit 1
}
finally {
    Pop-Location
}
```

### Example: Script with Parameters and Validation

```powershell
<#
.SYNOPSIS
Runs tests for a specific test category.

.DESCRIPTION
This script executes tests from the specified test category with optional
code coverage collection. Supports both unit and integration tests.

.PARAMETER Category
The test category to run. Valid values: Unit, Integration.Data, Integration.Controller.

.PARAMETER Coverage
When specified, collects code coverage metrics during test execution.

.EXAMPLE
.\Run-TestCategory.ps1 -Category Unit
Runs unit tests without code coverage.

.EXAMPLE
.\Run-TestCategory.ps1 -Category Integration.Data -Coverage
Runs data integration tests with code coverage collection.
#>

[CmdletBinding()]
param(
    [Parameter(Mandatory=$true)]
    [ValidateSet("Unit", "Integration.Data", "Integration.Controller")]
    [string]
    $Category,

    [Parameter()]
    [switch]
    $Coverage
)

$ErrorActionPreference = "Stop"

try {
    $TestPath = "$PSScriptRoot/../tests/$Category"

    if (-not (Test-Path $TestPath)) {
        throw "Test directory not found: $TestPath"
    }

    Push-Location $TestPath

    Write-Host "Running $Category tests..." -ForegroundColor Cyan

    if ($Coverage) {
        dotnet test --collect:"XPlat Code Coverage"
    }
    else {
        dotnet test
    }

    if ($LASTEXITCODE -ne 0) {
        throw "Tests failed with exit code $LASTEXITCODE"
    }

    Write-Host "OK All tests passed" -ForegroundColor Green
}
catch {
    Write-Error "Failed to run tests: $_"
    Write-Error $_.ScriptStackTrace
    exit 1
}
finally {
    Pop-Location
}
```

### Key Benefits

- **Consistency** - All scripts follow the same structure and conventions
- **Portability** - Scripts run from any directory using `$PSScriptRoot`
- **Reliability** - Comprehensive error handling with proper cleanup
- **Usability** - Clear help documentation and colored output for better UX
- **Maintainability** - Well-organized code with proper documentation

**Reference Examples:** See scripts in the [`scripts/`](scripts/) directory for production implementations.

## Documentation and Planning Pattern

**Always place planning documents and work-in-progress documentation in the correct location.**

1. **Planning documents location** - All architecture plans, design documents, and work-in-progress documentation MUST be placed in the `docs/wip/` directory, NOT in a top-level `plans/` directory or any other location.

2. **Never create top-level directories without asking** - Do not create new top-level directories in the solution (at the same level as `src/`, `docs/`, `tests/`) without explicitly asking the user first. This includes directories like `plans/`, `design/`, or similar.

3. **Work-in-progress documents** - Documents that are still being refined, proposals, and analysis work should go in `docs/wip/`:
   - Architecture proposals
   - Refactoring plans
   - Design analysis documents
   - TODO lists for complex features
   - Investigation notes

4. **Established documentation** - Once a document is finalized and represents the current state of the system, it should be moved to the appropriate location:
   - `docs/` - For general project documentation
   - `docs/adr/` - For Architecture Decision Records
   - Project-specific README files in relevant directories

### Examples

**Correct locations:**
- `docs/wip/TENANCY-DIRECTORY-RESTRUCTURE.md` - Planning document
- `docs/wip/API-CONTRACT-TESTS.md` - Work in progress
- `docs/ARCHITECTURE.md` - Established documentation
- `docs/adr/0001-spa-web-app.md` - Architecture decision record

**Incorrect locations:**
- `plans/tenancy-restructure.md` - ❌ Wrong directory
- `design/api-design.md` - ❌ Unauthorized top-level directory
- `tenancy-plan.md` - ❌ Wrong location (solution root)

### Benefits

- **Consistent organization** - Everyone knows where to find planning documents
- **Clear distinction** - Separates work-in-progress from established documentation
- **No clutter** - Prevents proliferation of top-level directories
- **Standard structure** - Follows established project conventions

## Collection Return Types Pattern

**Use `IReadOnlyCollection<T>` for collection return values in Application Features and Controller ProducesResponseType attributes.**

1. **Feature output (return values)** - Application Features that return collections MUST use `Task<IReadOnlyCollection<TDto>>`:
   ```csharp
   public async Task<IReadOnlyCollection<TransactionResultDto>> GetTransactionsAsync(...)
   {
       var result = await dataProvider.ToListNoTrackingAsync(query);
       return result; // List<T> implements IReadOnlyCollection<T>
   }
   ```

2. **Controller ProducesResponseType** - Controllers MUST use `IReadOnlyCollection<TDto>` in `[ProducesResponseType]` attributes to match Feature return types:
   ```csharp
   [HttpGet()]
   [ProducesResponseType(typeof(IReadOnlyCollection<TransactionResultDto>), StatusCodes.Status200OK)]
   public async Task<IActionResult> GetTransactions(...)
   {
       var transactions = await transactionsFeature.GetTransactionsAsync(...);
       return Ok(transactions); // No changes needed in method body
   }
   ```

3. **Feature input (parameters)** - Application Features that accept collections SHOULD use `IReadOnlyCollection<TDto>` for input parameters (NOT `IEnumerable<T>`):
   ```csharp
   public async Task BulkOperationAsync(IReadOnlyCollection<TransactionEditDto> items)
   {
       // No need for defensive .ToList() - already materialized by caller
       if (items.Count > 1000)
       {
           throw new ArgumentException("Too many items");
       }

       foreach (var item in items)
       {
           ValidateItem(item);
       }
       // ... process
   }
   ```

4. **Controller input (FromBody)** - Controllers receive concrete types from JSON deserialization and pass them to Features:
   ```csharp
   [HttpPost("bulk")]
   public async Task<IActionResult> BulkCreate([FromBody] TransactionEditDto[] items)
   {
       await feature.BulkOperationAsync(items); // Array → IReadOnlyCollection<T>
       return NoContent();
   }
   ```

### Why IReadOnlyCollection<T>?

**For outputs:**
- ✅ **Semantic accuracy** - Query results shouldn't be modified by callers
- ✅ **Includes `.Count`** - Efficient count access without enumeration
- ✅ **Zero overhead** - `List<T>` already implements it, no conversion needed
- ✅ **Flexibility** - Can change internal implementation without breaking callers

**For inputs:**
- ✅ **Caller materializes** - No defensive `.ToList()` needed in every method
- ✅ **Clear contract** - Signals "this is materialized, can enumerate multiple times"
- ✅ **No double allocation** - Avoids creating `List<T>` from an `Array`
- ✅ **Includes `.Count`** - Can validate size before processing

### What NOT to Use

**❌ Don't use for Feature returns:**
- `ICollection<T>` - Allows Add/Remove (wrong semantics for query results)
- `List<T>` - Too specific, couples callers to implementation
- `T[]` - Inflexible, unusual for modern APIs
- `IEnumerable<T>` - No `.Count`, misleading (suggests lazy evaluation)

**❌ Don't use for Feature inputs:**
- `IEnumerable<T>` - Forces defensive `.ToList()` in every method, wastes allocations
- `List<T>` - Too specific, couples to implementation
- `ICollection<T>` - Rarely need Add/Remove on inputs

### JSON Serialization Compatibility

All these types serialize identically to JSON arrays - no breaking changes:
- `IReadOnlyCollection<T>` → `[{...}, {...}]`
- `ICollection<T>` → `[{...}, {...}]`
- `List<T>` → `[{...}, {...}]`
- `T[]` → `[{...}, {...}]`

OpenAPI/Swagger schemas are also identical.

### Reference Documentation

See [`docs/wip/APPLICATION-FEATURE-RETURN-VALUES.md`](docs/wip/APPLICATION-FEATURE-RETURN-VALUES.md) for comprehensive analysis including:
- Detailed comparison of all collection types
- Performance benchmarks
- Multiple enumeration risks with `IEnumerable<T>`
- Complete before/after examples
