# Project-specific rules for Roo AI assistant

## Files to Never Edit

### Auto-generated API Client

- **NEVER** edit `app/utils/apiclient.ts` - this file is auto-generated using the NSwag toolchain from the backend API specification
- Any changes to this file will be overwritten when the API client is regenerated
- To modify API client behavior, update the backend API or NSwag configuration instead

## Error Handling Patterns

### API Exception Handling

When working with API clients, always use the `handleApiError` helper from the error handler utility:

```typescript
import { handleApiError } from '~/utils/errorHandler'
import type { IProblemDetails } from '~/utils/apiclient'

// State
const error = ref<IProblemDetails | undefined>(undefined)
const showError = ref(false)

// API call with proper error handling
try {
  await apiClient.someMethod()
} catch (err) {
  error.value = handleApiError(err)
  showError.value = true
}
```

**With custom fallback messages:**

```typescript
try {
  await apiClient.deleteItem(id)
} catch (err) {
  error.value = handleApiError(err, 'Delete Failed', 'Could not delete the item')
  showError.value = true
}
```

**Rules:**

- **ALWAYS** use `handleApiError()` helper for API client error handling - it's DRY and consistent
- **NEVER** use `catch (err: any)` - use `catch (err)` instead
- **NEVER** manually check `ApiException.isApiException(err)` - the helper handles this
- **DO** provide custom fallback title/detail for better UX when appropriate
- **DO** clear errors before API calls: `error.value = undefined` and `showError.value = false`

### ErrorDisplay Component

Use the `ErrorDisplay` component for all error messages:

```vue
<ErrorDisplay v-model:show="showError" :problem="error" class="mb-4" />
```

**Benefits:**

- Consistent error display across the application
- Supports RFC 7807 Problem Details format
- Shows trace IDs for server errors (500+)
- Dismissible by users
- Handles expandable details automatically

### Client-Side Validation Errors

For validation errors that don't involve API calls:

```typescript
if (!formData.value.trim()) {
  error.value = {
    title: 'Validation Error',
    detail: 'Field name is required',
  }
  showError.value = true
  return
}
```

### Error State Management

**Always:**

- Clear errors before making API calls: `error.value = undefined` and `showError.value = false`
- Store errors as `IProblemDetails | undefined`, not strings
- Use a separate `showError` boolean to control `ErrorDisplay` visibility

## Testing Patterns

### Data Test IDs for Functional Tests

**ALWAYS** add `data-test-id` attributes to elements that:
- Users interact with (buttons, links, inputs, form fields)
- Display important state or data (error messages, success messages, loading indicators, headings)
- Are used in automated functional tests

**Rules:**

- **ALWAYS** add `data-test-id` to interactive elements:
  - Buttons: `data-test-id="action-button"` (e.g., `"create-submit-button"`, `"edit-cancel-button"`)
  - Links: `data-test-id="navigation-link"` (e.g., `"create-account-link"`, `"sign-in-link"`)
  - Form inputs: `data-test-id="field-name"` (e.g., `"username"`, `"email"`, `"password"`)
  - Form containers: `data-test-id="FormName"` (e.g., `"LoginForm"`, `"RegisterForm"`)

- **ALWAYS** add `data-test-id` to state display elements:
  - Page headings: `data-test-id="page-heading"`
  - Error displays: `data-test-id="error-display"` or `data-test-id="Errors"`
  - Success messages: `data-test-id="SuccessMessage"`
  - Loading indicators: `data-test-id="loading-state"`, `data-test-id="BaseSpinner"`
  - Empty states: `data-test-id="empty-state"`
  - Status badges: `data-test-id="status-badge"`, `data-test-id="role-badge"`

- **ALWAYS** add `data-test-id` to list items and cards:
  - Use unique identifiers: `data-test-id="item-row-{key}"` or `data-test-id="item-card-{key}"`
  - Examples: `"transaction-row-{transactionKey}"`, `"workspace-card-{workspaceKey}"`

- **Naming Conventions:**
  - Use kebab-case: `data-test-id="create-submit-button"` (NOT camelCase or PascalCase)
  - Be descriptive and specific: `"new-transaction-button"` not just `"button"`
  - Use consistent patterns: `"{action}-submit-button"`, `"{action}-cancel-button"`
  - For forms: Use the field name: `"username"`, `"email"`, `"password"`, NOT `"username-input"`

### Client-Ready Pattern for SSR/Hydration

**CRITICAL**: When creating pages that will be tested with Playwright, implement the client-ready pattern to signal when Vue hydration is complete:

```vue
<script setup lang="ts">
// 1. Create a ready ref that starts false
const ready = ref(false)

// 2. Set to true once component is mounted (client-side only)
onMounted(() => {
  ready.value = true
})
</script>

<template>
  <!-- 3. Disable interactive elements until ready -->
  <button
    type="submit"
    data-test-id="Login"
    :disabled="isLoading || !ready"
  >
    Sign In
  </button>
</template>
```

**Why This Is Critical:**

- Initial page navigation delivers **server-rendered (SSR) HTML that is non-interactive**
- Vue must "hydrate" this HTML to make it interactive
- Tests that interact with elements before hydration completes will fail or behave unexpectedly
- The `ready` ref pattern prevents tests from interacting with non-hydrated elements

**Rules:**

- **ALWAYS** add `const ready = ref(false)` to pages that will be tested
- **ALWAYS** add `onMounted(() => { ready.value = true })` hook
- **ALWAYS** include `!ready` in button disabled conditions: `:disabled="isLoading || !ready"`
- **ALWAYS** combine with loading state - never use ready alone

**See:** [`tests/Functional/NUXT-SSR-TESTING-PATTERN.md`](../../tests/Functional/NUXT-SSR-TESTING-PATTERN.md) for complete documentation and rationale.

### Loading State Pattern

**ALWAYS** implement the loading state pattern for async operations (form submissions, API calls):

```vue
<button
  type="submit"
  data-test-id="create-submit-button"
  :disabled="isSubmitting"
>
  <BaseSpinner v-if="isSubmitting" size="sm" class="me-1" />
  {{ isSubmitting ? 'Creating...' : 'Create' }}
</button>
```

**Rules:**

- **ALWAYS** use `:disabled` binding tied to loading state (e.g., `isLoading`, `isSubmitting`, `creating`)
- **ALWAYS** show a spinner during loading: `<BaseSpinner v-if="isLoading" size="sm" />`
- **ALWAYS** change button text to show loading state: `{{ isLoading ? 'Loading...' : 'Load' }}`
- **NEVER** create separate buttons/locators for loading vs. non-loading states
- **NEVER** rely on button text for test locators - use stable `data-test-id` instead

**Benefits:**
- ✅ Tests detect loading state via `.IsDisabledAsync()` on the button
- ✅ Button text can change without breaking tests
- ✅ Supports internationalization (text in any language)
- ✅ No race conditions catching transitional states
- ✅ Consistent UX across all forms

### Reusable Components with Test IDs

When creating reusable components (like `ModalDialog`), **ALWAYS** support `data-test-id` props:

```vue
<script setup lang="ts">
interface Props {
  // ... other props
  primaryButtonTestId?: string
  secondaryButtonTestId?: string
}

const props = withDefaults(defineProps<Props>(), {
  // ... defaults
  primaryButtonTestId: '',
  secondaryButtonTestId: '',
})
</script>

<template>
  <button :data-test-id="primaryButtonTestId">
    {{ primaryButtonText }}
  </button>
  <button :data-test-id="secondaryButtonTestId">
    {{ secondaryButtonText }}
  </button>
</template>
```

**Usage:**

```vue
<ModalDialog
  v-model:show="showModal"
  title="Create Item"
  :loading="creating"
  :primary-button-text="creating ? 'Creating...' : 'Create'"
  primary-button-test-id="create-submit-button"
  secondary-button-test-id="create-cancel-button"
  @primary="createItem"
/>
```

### Testing Best Practices

- **DO** add `data-test-id` during initial development, not as an afterthought
- **DO** use the same `data-test-id` values that functional tests expect (check `tests/Functional/Pages/`)
- **DO** keep test IDs stable - never change them without updating tests
- **DON'T** use generated IDs like `id="input-1234"` for test locators
- **DON'T** rely on CSS classes for test locators (they change with styling)
- **DON'T** rely on text content for locators (changes with i18n, copy updates)
- **DON'T** use ARIA roles alone (not stable enough for automation)

## Documentation Pattern

### JSDoc for TypeScript Code

**ALWAYS** add JSDoc documentation comments to all new TypeScript code, including Vue pages and components.

TypeScript code uses **JSDoc** (not Javadoc) for documentation. JSDoc uses `/** */` block comment syntax and is the standard for JavaScript and TypeScript.

#### What to Document

**ALWAYS document:**
- Component-level overview (at the top of `<script setup>`)
- Interfaces (Props, Emits, custom types)
- Reactive references and composables
- Functions and methods
- Computed properties
- Watchers
- Lifecycle hooks (when non-obvious)

#### JSDoc Tags

Common tags to use:
- `@param` - Document function parameters
- `@returns` / `@return` - Document return values
- `@throws` - Document exceptions (rare in Vue/TypeScript)
- `@example` - Provide usage examples (for composables/utilities)
- `@deprecated` - Mark deprecated code

#### Principles

1. **Focus on behavior, not types** - TypeScript's type system provides type information, so JSDoc should explain *what the code does* rather than duplicating type annotations

2. **Be concise** - Short, clear descriptions are better than lengthy explanations

3. **IDE IntelliSense** - JSDoc comments appear in IDE tooltips and autocomplete, making them valuable for developer experience

#### Examples

**Component overview:**
```vue
<script setup lang="ts">
/**
 * Payee Rules Management Page
 *
 * Allows users to view, search, sort, create, edit, and delete payee matching rules.
 */
```

**Props interface:**
```typescript
/**
 * Component props for PayeeRuleDialog.
 */
interface Props {
  /** Whether the dialog is visible */
  show: boolean

  /** Dialog mode - create new rule or edit existing rule */
  mode: 'create' | 'edit'

  /** Whether the save operation is in progress */
  loading?: boolean

  /** Initial value for payee pattern field (used in edit mode) */
  initialPayeePattern?: string
}
```

**Emits:**
```typescript
/**
 * Component events emitted by PayeeRuleDialog.
 */
const emit = defineEmits<{
  /** Emitted when dialog visibility changes (v-model support) */
  'update:show': [value: boolean]

  /** Emitted when user saves the rule */
  save: [rule: PayeeMatchingRuleEditDto]

  /** Emitted when user cancels the dialog */
  cancel: []
}>()
```

**Reactive references:**
```typescript
/**
 * List of payee matching rules loaded from the API.
 */
const rules = ref<PayeeMatchingRuleResultDto[]>([])

/**
 * Whether a loading operation is in progress.
 */
const loading = ref(false)

/**
 * User preferences store for managing current tenant/workspace selection.
 */
const userPreferencesStore = useUserPreferencesStore()
```

**Functions:**
```typescript
/**
 * Creates a new payee matching rule.
 * Reloads the rules list on success and closes the dialog.
 *
 * @param rule - The rule data to create
 */
async function createRule(rule: PayeeMatchingRuleEditDto) {
  // Implementation
}

/**
 * Converts a TenantRole enum value to a human-readable string.
 *
 * @param role - The tenant role enum value
 * @returns Human-readable role name (Owner, Editor, Viewer, or Unknown)
 */
function getRoleName(role: TenantRole | undefined): string {
  // Implementation
}
```

**Computed properties:**
```typescript
/**
 * Whether the current user has permission to edit rules.
 * Requires Editor or Owner role in the current workspace.
 *
 * @returns True if user can create, edit, or delete rules
 */
const canEditRules = computed(() => {
  // Implementation
})

/**
 * Total count of rules matching the current filters.
 *
 * @returns Total count from pagination metadata or 0
 */
const totalCount = computed(() => paginationMetadata.value?.totalCount || 0)
```

**Watchers:**
```typescript
/**
 * Watch for workspace changes and reload rules.
 * Clears rules list when no workspace is selected.
 */
watch(currentTenantKey, async (newKey) => {
  // Implementation
})
```

**Lifecycle hooks:**
```typescript
/**
 * Load user preferences and initial rules on component mount.
 */
onMounted(async () => {
  // Implementation
})
```

#### Rules

- **DO** add JSDoc to all new TypeScript code (components, pages, composables, utilities)
- **DO** document the "why" and "what", not the "how"
- **DO** use `@param` for all function parameters
- **DO** use `@returns` for functions that return values (except `void`, `Task`, or `Task<IActionResult>`)
- **DON'T** duplicate type information that TypeScript already provides
- **DON'T** use `@param {type}` syntax - TypeScript types are sufficient
- **DON'T** write lengthy documentation - keep it concise and focused

#### Reference Examples

See these files for comprehensive JSDoc documentation examples:
- [`src/FrontEnd.Nuxt/app/components/PayeeRuleDialog.vue`](app/components/PayeeRuleDialog.vue)
- [`src/FrontEnd.Nuxt/app/components/WorkspaceSelector.vue`](app/components/WorkspaceSelector.vue)
- [`src/FrontEnd.Nuxt/app/pages/payee-rules/index.vue`](app/pages/payee-rules/index.vue)
