//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* eslint-disable */
// ReSharper disable InconsistentNaming

export class AuthClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Authenticates a user with username and password.
     * @param request Login credentials.
     * @return JWT tokens and user information if successful; otherwise, unauthorized.
     */
    login(request: LoginRequest): Promise<LoginResponse> {
        let url_ = this.baseUrl + "/api/auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: Response): Promise<LoginResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoginResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LoginResponse>(null as any);
    }

    /**
     * Registers a new user.
     * @param request Signup credentials.
     * @return JWT tokens and user information if successful; otherwise, bad request.
     */
    signUp(request: SignUpRequest): Promise<LoginResponse> {
        let url_ = this.baseUrl + "/api/auth/signup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSignUp(_response);
        });
    }

    protected processSignUp(response: Response): Promise<LoginResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoginResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LoginResponse>(null as any);
    }

    /**
     * Retrieves the current user's session information.
     * @return User information if authenticated; otherwise, unauthorized.
     */
    getSession(): Promise<SessionResponse> {
        let url_ = this.baseUrl + "/api/auth/user";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSession(_response);
        });
    }

    protected processGetSession(response: Response): Promise<SessionResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SessionResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SessionResponse>(null as any);
    }

    /**
     * Handles token refresh logic. Can be overridden for custom behavior.
     * @param request The refresh token request.
     * @return New token pair if successful; otherwise, unauthorized.
     */
    refreshTokens(request: RefreshRequest): Promise<RefreshResponse> {
        let url_ = this.baseUrl + "/api/auth/refresh";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRefreshTokens(_response);
        });
    }

    protected processRefreshTokens(response: Response): Promise<RefreshResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RefreshResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RefreshResponse>(null as any);
    }

    /**
     * Handles logout logic. Can be overridden for custom behavior.
     * @param request The logout request containing the refresh token to revoke.
     * @return Success response.
     */
    logout(request: RefreshRequest): Promise<void> {
        let url_ = this.baseUrl + "/api/auth/logout";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogout(_response);
        });
    }

    protected processLogout(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class ImportClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Uploads an OFX/QFX file, parses transactions, detects duplicates, and stores them for review.
     * @param file (optional) 
     * @return Import result containing statistics and any parsing errors.
     */
    uploadFile(tenantKey: string, file: FileParameter | null | undefined): Promise<ImportReviewUploadDto> {
        let url_ = this.baseUrl + "/api/tenant/{tenantKey}/import/upload";
        if (tenantKey === undefined || tenantKey === null)
            throw new globalThis.Error("The parameter 'tenantKey' must be defined.");
        url_ = url_.replace("{tenantKey}", encodeURIComponent("" + tenantKey));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUploadFile(_response);
        });
    }

    protected processUploadFile(response: Response): Promise<ImportReviewUploadDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImportReviewUploadDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ImportReviewUploadDto>(null as any);
    }

    /**
     * Retrieves pending import review transactions for the current tenant with pagination support.
     * @param pageNumber (optional) The page number to retrieve (default: 1).
     * @param pageSize (optional) The number of items per page (default: 50, max: 1000).
     * @return Paginated response containing transactions and pagination metadata.
     */
    getPendingReview(pageNumber: number | null | undefined, pageSize: number | null | undefined, tenantKey: string): Promise<PaginatedResultDtoOfImportReviewTransactionDto> {
        let url_ = this.baseUrl + "/api/tenant/{tenantKey}/import/review?";
        if (tenantKey === undefined || tenantKey === null)
            throw new globalThis.Error("The parameter 'tenantKey' must be defined.");
        url_ = url_.replace("{tenantKey}", encodeURIComponent("" + tenantKey));
        if (pageNumber !== undefined && pageNumber !== null)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize !== undefined && pageSize !== null)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPendingReview(_response);
        });
    }

    protected processGetPendingReview(response: Response): Promise<PaginatedResultDtoOfImportReviewTransactionDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedResultDtoOfImportReviewTransactionDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaginatedResultDtoOfImportReviewTransactionDto>(null as any);
    }

    /**
     * Deletes all pending import review transactions for the current tenant.
     */
    deleteAllPendingReview(tenantKey: string): Promise<void> {
        let url_ = this.baseUrl + "/api/tenant/{tenantKey}/import/review";
        if (tenantKey === undefined || tenantKey === null)
            throw new globalThis.Error("The parameter 'tenantKey' must be defined.");
        url_ = url_.replace("{tenantKey}", encodeURIComponent("" + tenantKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteAllPendingReview(_response);
        });
    }

    protected processDeleteAllPendingReview(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Completes the import review by accepting selected transactions and deleting all pending review transactions.
     * @param keys The collection of transaction keys to accept (import into main transaction table).
     * @return Result indicating the number of transactions accepted and rejected.
     */
    completeReview(tenantKey: string, keys: string[]): Promise<ImportReviewCompleteDto> {
        let url_ = this.baseUrl + "/api/tenant/{tenantKey}/import/review/complete";
        if (tenantKey === undefined || tenantKey === null)
            throw new globalThis.Error("The parameter 'tenantKey' must be defined.");
        url_ = url_.replace("{tenantKey}", encodeURIComponent("" + tenantKey));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(keys);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCompleteReview(_response);
        });
    }

    protected processCompleteReview(response: Response): Promise<ImportReviewCompleteDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImportReviewCompleteDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ImportReviewCompleteDto>(null as any);
    }
}

export class TestControlClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Create a test user with auto-generated username
     * @return Created user credentials including ID and password
     */
    createUser(): Promise<TestUserCredentials> {
        let url_ = this.baseUrl + "/TestControl/users";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateUser(_response);
        });
    }

    protected processCreateUser(response: Response): Promise<TestUserCredentials> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = TestUserCredentials.fromJS(resultData201);
            return result201;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TestUserCredentials>(null as any);
    }

    /**
     * Deletes all test users from the system.
     * @return 204 No Content on success.
     */
    deleteUsers(): Promise<void> {
        let url_ = this.baseUrl + "/TestControl/users";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteUsers(_response);
        });
    }

    protected processDeleteUsers(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Create multiple test users in bulk with credentials
     * @param usernames Collection of usernames to create (must include __TEST__ prefix)
     * @return Collection of created user credentials including IDs and passwords
     */
    createBulkUsers(usernames: string[]): Promise<TestUserCredentials[]> {
        let url_ = this.baseUrl + "/TestControl/users/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(usernames);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateBulkUsers(_response);
        });
    }

    protected processCreateBulkUsers(response: Response): Promise<TestUserCredentials[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201!.push(TestUserCredentials.fromJS(item));
            }
            else {
                result201 = null as any;
            }
            return result201;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TestUserCredentials[]>(null as any);
    }

    /**
     * Approve a test user
     */
    approveUser(username: string): Promise<void> {
        let url_ = this.baseUrl + "/TestControl/users/{username}/approve";
        if (username === undefined || username === null)
            throw new globalThis.Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApproveUser(_response);
        });
    }

    protected processApproveUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Create a workspace for a test user with specified role.
     * @param username The username (must include __TEST__ prefix) of the user.
     * @param request The workspace creation details.
     * @return The created workspace information.
     */
    createWorkspaceForUser(username: string, request: WorkspaceCreateRequest): Promise<TenantResultDto> {
        let url_ = this.baseUrl + "/TestControl/users/{username}/workspaces";
        if (username === undefined || username === null)
            throw new globalThis.Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateWorkspaceForUser(_response);
        });
    }

    protected processCreateWorkspaceForUser(response: Response): Promise<TenantResultDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = TenantResultDto.fromJS(resultData201);
            return result201;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TenantResultDto>(null as any);
    }

    /**
     * Assign a user to an existing workspace with a specific role.
     * @param username The username (must include __TEST__ prefix) of the user.
     * @param workspaceKey The unique key of the workspace.
     * @param assignment The role assignment details.
     * @return 204 No Content on success.
     */
    assignUserToWorkspace(username: string, workspaceKey: string, assignment: UserRoleAssignment): Promise<void> {
        let url_ = this.baseUrl + "/TestControl/users/{username}/workspaces/{workspaceKey}/assign";
        if (username === undefined || username === null)
            throw new globalThis.Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username));
        if (workspaceKey === undefined || workspaceKey === null)
            throw new globalThis.Error("The parameter 'workspaceKey' must be defined.");
        url_ = url_.replace("{workspaceKey}", encodeURIComponent("" + workspaceKey));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(assignment);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAssignUserToWorkspace(_response);
        });
    }

    protected processAssignUserToWorkspace(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("A server side error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Seed test transactions in a workspace for a user.
     * @param username The username (must include __TEST__ prefix) of the user.
     * @param tenantKey The unique key of the workspace.
     * @param request The transaction seeding details.
     * @return The collection of created transactions.
     */
    seedTransactions(username: string, tenantKey: string, request: TransactionSeedRequest): Promise<TransactionResultDto[]> {
        let url_ = this.baseUrl + "/TestControl/users/{username}/workspaces/{tenantKey}/transactions/seed";
        if (username === undefined || username === null)
            throw new globalThis.Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username));
        if (tenantKey === undefined || tenantKey === null)
            throw new globalThis.Error("The parameter 'tenantKey' must be defined.");
        url_ = url_.replace("{tenantKey}", encodeURIComponent("" + tenantKey));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSeedTransactions(_response);
        });
    }

    protected processSeedTransactions(response: Response): Promise<TransactionResultDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201!.push(TransactionResultDto.fromJS(item));
            }
            else {
                result201 = null as any;
            }
            return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TransactionResultDto[]>(null as any);
    }

    /**
     * Delete all test data including test users and test workspaces.
     * @return 204 No Content on success.
     */
    deleteAllTestData(): Promise<void> {
        let url_ = this.baseUrl + "/TestControl/data";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteAllTestData(_response);
        });
    }

    protected processDeleteAllTestData(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Create multiple workspaces for a user in a single request.
     * @param username The username (must include __TEST__ prefix) of the user.
     * @param workspaces The collection of workspace setup requests.
     * @return The collection of created workspace results with keys and roles.
     */
    bulkWorkspaceSetup(username: string, workspaces: WorkspaceSetupRequest[]): Promise<WorkspaceSetupResult[]> {
        let url_ = this.baseUrl + "/TestControl/users/{username}/workspaces/bulk";
        if (username === undefined || username === null)
            throw new globalThis.Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(workspaces);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBulkWorkspaceSetup(_response);
        });
    }

    protected processBulkWorkspaceSetup(response: Response): Promise<WorkspaceSetupResult[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201!.push(WorkspaceSetupResult.fromJS(item));
            }
            else {
                result201 = null as any;
            }
            return result201;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkspaceSetupResult[]>(null as any);
    }

    /**
     * List available error codes that can be generated for testing
     * @return A collection of error code descriptions
     */
    listErrors(): Promise<ErrorCodeInfo[]> {
        let url_ = this.baseUrl + "/TestControl/errors";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processListErrors(_response);
        });
    }

    protected processListErrors(response: Response): Promise<ErrorCodeInfo[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ErrorCodeInfo.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ErrorCodeInfo[]>(null as any);
    }

    /**
     * Generate various error codes for testing purposes
     * @param code Kind of error desired
     */
    returnError(code: string): Promise<void> {
        let url_ = this.baseUrl + "/TestControl/errors/{code}";
        if (code === undefined || code === null)
            throw new globalThis.Error("The parameter 'code' must be defined.");
        url_ = url_.replace("{code}", encodeURIComponent("" + code));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReturnError(_response);
        });
    }

    protected processReturnError(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("A server side error occurred.", status, _responseText, _headers, result409);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get a paginated result of test strings.
     * @param pageNumber (optional) The page number (1-based). Defaults to 1.
     * @param pageSize (optional) The number of items per page. Defaults to 10.
     * @return A paginated result containing test strings.
     */
    getPaginatedStrings(pageNumber: number | undefined, pageSize: number | undefined): Promise<PaginatedResultDtoOfString> {
        let url_ = this.baseUrl + "/TestControl/pagination/strings?";
        if (pageNumber === null)
            throw new globalThis.Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "pageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPaginatedStrings(_response);
        });
    }

    protected processGetPaginatedStrings(response: Response): Promise<PaginatedResultDtoOfString> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedResultDtoOfString.fromJS(resultData200);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaginatedResultDtoOfString>(null as any);
    }
}

export class TransactionsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Retrieves all transactions for the tenant, optionally filtered by date range.
     * @param fromDate (optional) The starting date for the date range filter (inclusive). If null, no lower bound is applied.
     * @param toDate (optional) The ending date for the date range filter (inclusive). If null, no upper bound is applied.
     */
    getTransactions(fromDate: Date | null | undefined, toDate: Date | null | undefined, tenantKey: string): Promise<TransactionResultDto[]> {
        let url_ = this.baseUrl + "/api/tenant/{tenantKey}/Transactions?";
        if (tenantKey === undefined || tenantKey === null)
            throw new globalThis.Error("The parameter 'tenantKey' must be defined.");
        url_ = url_.replace("{tenantKey}", encodeURIComponent("" + tenantKey));
        if (fromDate !== undefined && fromDate !== null)
            url_ += "fromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate !== undefined && toDate !== null)
            url_ += "toDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTransactions(_response);
        });
    }

    protected processGetTransactions(response: Response): Promise<TransactionResultDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TransactionResultDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TransactionResultDto[]>(null as any);
    }

    /**
     * Creates a new transaction in the tenant workspace.
     * @param tenantKey The unique identifier of the tenant (from route).
     * @param transaction The transaction data including date, amount, and payee.
     */
    createTransaction(tenantKey: string, transaction: TransactionEditDto): Promise<TransactionDetailDto> {
        let url_ = this.baseUrl + "/api/tenant/{tenantKey}/Transactions";
        if (tenantKey === undefined || tenantKey === null)
            throw new globalThis.Error("The parameter 'tenantKey' must be defined.");
        url_ = url_.replace("{tenantKey}", encodeURIComponent("" + tenantKey));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(transaction);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateTransaction(_response);
        });
    }

    protected processCreateTransaction(response: Response): Promise<TransactionDetailDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = TransactionDetailDto.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TransactionDetailDto>(null as any);
    }

    /**
     * Retrieves a specific transaction by its unique key.
     * @param key The unique identifier of the transaction.
     */
    getTransactionById(key: string, tenantKey: string): Promise<TransactionDetailDto> {
        let url_ = this.baseUrl + "/api/tenant/{tenantKey}/Transactions/{key}";
        if (key === undefined || key === null)
            throw new globalThis.Error("The parameter 'key' must be defined.");
        url_ = url_.replace("{key}", encodeURIComponent("" + key));
        if (tenantKey === undefined || tenantKey === null)
            throw new globalThis.Error("The parameter 'tenantKey' must be defined.");
        url_ = url_.replace("{tenantKey}", encodeURIComponent("" + tenantKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTransactionById(_response);
        });
    }

    protected processGetTransactionById(response: Response): Promise<TransactionDetailDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TransactionDetailDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TransactionDetailDto>(null as any);
    }

    /**
     * Updates an existing transaction in the tenant workspace.
     * @param key The unique identifier of the transaction to update.
     * @param transaction The updated transaction data including date, amount, and payee.
     */
    updateTransaction(key: string, tenantKey: string, transaction: TransactionEditDto): Promise<TransactionDetailDto> {
        let url_ = this.baseUrl + "/api/tenant/{tenantKey}/Transactions/{key}";
        if (key === undefined || key === null)
            throw new globalThis.Error("The parameter 'key' must be defined.");
        url_ = url_.replace("{key}", encodeURIComponent("" + key));
        if (tenantKey === undefined || tenantKey === null)
            throw new globalThis.Error("The parameter 'tenantKey' must be defined.");
        url_ = url_.replace("{tenantKey}", encodeURIComponent("" + tenantKey));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(transaction);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateTransaction(_response);
        });
    }

    protected processUpdateTransaction(response: Response): Promise<TransactionDetailDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TransactionDetailDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TransactionDetailDto>(null as any);
    }

    /**
     * Quick edit: updates only payee and memo, preserving all other transaction fields.
     * @param key The unique identifier of the transaction to update.
     * @param quickEdit The updated payee and memo values.
     */
    quickEditTransaction(key: string, tenantKey: string, quickEdit: TransactionQuickEditDto): Promise<TransactionDetailDto> {
        let url_ = this.baseUrl + "/api/tenant/{tenantKey}/Transactions/{key}";
        if (key === undefined || key === null)
            throw new globalThis.Error("The parameter 'key' must be defined.");
        url_ = url_.replace("{key}", encodeURIComponent("" + key));
        if (tenantKey === undefined || tenantKey === null)
            throw new globalThis.Error("The parameter 'tenantKey' must be defined.");
        url_ = url_.replace("{tenantKey}", encodeURIComponent("" + tenantKey));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(quickEdit);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processQuickEditTransaction(_response);
        });
    }

    protected processQuickEditTransaction(response: Response): Promise<TransactionDetailDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TransactionDetailDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TransactionDetailDto>(null as any);
    }

    /**
     * Deletes a transaction from the tenant workspace.
     * @param key The unique identifier of the transaction to delete.
     */
    deleteTransaction(key: string, tenantKey: string): Promise<void> {
        let url_ = this.baseUrl + "/api/tenant/{tenantKey}/Transactions/{key}";
        if (key === undefined || key === null)
            throw new globalThis.Error("The parameter 'key' must be defined.");
        url_ = url_.replace("{key}", encodeURIComponent("" + key));
        if (tenantKey === undefined || tenantKey === null)
            throw new globalThis.Error("The parameter 'tenantKey' must be defined.");
        url_ = url_.replace("{tenantKey}", encodeURIComponent("" + tenantKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteTransaction(_response);
        });
    }

    protected processDeleteTransaction(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class VersionClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Retrieves the current application version.
     * @return The version string, optionally with environment name in non-production environments.
     */
    getVersion(): Promise<string> {
        let url_ = this.baseUrl + "/Version";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetVersion(_response);
        });
    }

    protected processGetVersion(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : null as any;
    
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }
}

export class WeatherClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Retrieves weather forecasts for the next 5 days.
     * @return A collection of weather forecasts starting from today.
     */
    getWeatherForecasts(): Promise<WeatherForecast[]> {
        let url_ = this.baseUrl + "/api/Weather";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetWeatherForecasts(_response);
        });
    }

    protected processGetWeatherForecasts(response: Response): Promise<WeatherForecast[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WeatherForecast.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WeatherForecast[]>(null as any);
    }
}

export class TenantClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Get all tenants for current user
     */
    getTenants(): Promise<TenantRoleResultDto[]> {
        let url_ = this.baseUrl + "/api/Tenant";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTenants(_response);
        });
    }

    protected processGetTenants(response: Response): Promise<TenantRoleResultDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TenantRoleResultDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TenantRoleResultDto[]>(null as any);
    }

    /**
     * Create a new tenant, with current user as owner
     * @param tenantDto The tenant data including name and description
     * @return The created tenant's information
     */
    createTenant(tenantDto: TenantEditDto): Promise<TenantResultDto> {
        let url_ = this.baseUrl + "/api/Tenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tenantDto);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateTenant(_response);
        });
    }

    protected processCreateTenant(response: Response): Promise<TenantResultDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = TenantResultDto.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TenantResultDto>(null as any);
    }

    /**
     * Get a specific tenant for current user by tenant key
     * @param key The unique key of the tenant
     * @return The tenant with the user's role if they have access
     */
    getTenant(key: string): Promise<TenantRoleResultDto> {
        let url_ = this.baseUrl + "/api/Tenant/{key}";
        if (key === undefined || key === null)
            throw new globalThis.Error("The parameter 'key' must be defined.");
        url_ = url_.replace("{key}", encodeURIComponent("" + key));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTenant(_response);
        });
    }

    protected processGetTenant(response: Response): Promise<TenantRoleResultDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantRoleResultDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TenantRoleResultDto>(null as any);
    }

    /**
     * Update an existing tenant (requires Owner role)
     * @param tenantKey The unique key of the tenant to update
     * @param tenantDto The updated tenant data including name and description
     * @return The updated tenant's information
     */
    updateTenant(tenantKey: string, tenantDto: TenantEditDto): Promise<TenantResultDto> {
        let url_ = this.baseUrl + "/api/Tenant/{tenantKey}";
        if (tenantKey === undefined || tenantKey === null)
            throw new globalThis.Error("The parameter 'tenantKey' must be defined.");
        url_ = url_.replace("{tenantKey}", encodeURIComponent("" + tenantKey));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tenantDto);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateTenant(_response);
        });
    }

    protected processUpdateTenant(response: Response): Promise<TenantResultDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantResultDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TenantResultDto>(null as any);
    }

    /**
     * Delete a tenant (requires Owner role)
     * @param tenantKey The unique key of the tenant to delete
     * @return No content on successful deletion
     */
    deleteTenant(tenantKey: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Tenant/{tenantKey}";
        if (tenantKey === undefined || tenantKey === null)
            throw new globalThis.Error("The parameter 'tenantKey' must be defined.");
        url_ = url_.replace("{tenantKey}", encodeURIComponent("" + tenantKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteTenant(_response);
        });
    }

    protected processDeleteTenant(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class LoginResponse implements ILoginResponse {
    token?: TokenPair;
    user?: UserInfo;

    constructor(data?: ILoginResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"] ? TokenPair.fromJS(_data["token"]) : undefined as any;
            this.user = _data["user"] ? UserInfo.fromJS(_data["user"]) : undefined as any;
        }
    }

    static fromJS(data: any): LoginResponse {
        data = typeof data === 'object' ? data : {};
        let result = new LoginResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token ? this.token.toJSON() : undefined as any;
        data["user"] = this.user ? this.user.toJSON() : undefined as any;
        return data;
    }
}

export interface ILoginResponse {
    token?: TokenPair;
    user?: UserInfo;
}

export class TokenPair implements ITokenPair {
    accessToken?: string;
    refreshToken?: string;

    constructor(data?: ITokenPair) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): TokenPair {
        data = typeof data === 'object' ? data : {};
        let result = new TokenPair();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["refreshToken"] = this.refreshToken;
        return data;
    }
}

export interface ITokenPair {
    accessToken?: string;
    refreshToken?: string;
}

export class UserInfo implements IUserInfo {
    id?: string;
    name?: string;
    email?: string;
    roles?: string[];
    claims?: ClaimInfo[];

    constructor(data?: IUserInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.email = _data["email"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
            if (Array.isArray(_data["claims"])) {
                this.claims = [] as any;
                for (let item of _data["claims"])
                    this.claims!.push(ClaimInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserInfo {
        data = typeof data === 'object' ? data : {};
        let result = new UserInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["email"] = this.email;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IUserInfo {
    id?: string;
    name?: string;
    email?: string;
    roles?: string[];
    claims?: ClaimInfo[];
}

export class ClaimInfo implements IClaimInfo {
    type?: string;
    value?: string;

    constructor(data?: IClaimInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ClaimInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ClaimInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["value"] = this.value;
        return data;
    }
}

export interface IClaimInfo {
    type?: string;
    value?: string;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export class LoginRequest implements ILoginRequest {
    username?: string;
    password?: string;

    constructor(data?: ILoginRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LoginRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["password"] = this.password;
        return data;
    }
}

export interface ILoginRequest {
    username?: string;
    password?: string;
}

export class SignUpRequest implements ISignUpRequest {
    username?: string;
    email?: string;
    password?: string;

    constructor(data?: ISignUpRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): SignUpRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SignUpRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface ISignUpRequest {
    username?: string;
    email?: string;
    password?: string;
}

export class SessionResponse implements ISessionResponse {
    user?: UserInfo | undefined;

    constructor(data?: ISessionResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user = _data["user"] ? UserInfo.fromJS(_data["user"]) : undefined as any;
        }
    }

    static fromJS(data: any): SessionResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SessionResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : undefined as any;
        return data;
    }
}

export interface ISessionResponse {
    user?: UserInfo | undefined;
}

export class RefreshResponse implements IRefreshResponse {
    token?: TokenPair;

    constructor(data?: IRefreshResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"] ? TokenPair.fromJS(_data["token"]) : undefined as any;
        }
    }

    static fromJS(data: any): RefreshResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token ? this.token.toJSON() : undefined as any;
        return data;
    }
}

export interface IRefreshResponse {
    token?: TokenPair;
}

export class RefreshRequest implements IRefreshRequest {
    refreshToken?: string;

    constructor(data?: IRefreshRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): RefreshRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["refreshToken"] = this.refreshToken;
        return data;
    }
}

export interface IRefreshRequest {
    refreshToken?: string;
}

export class ImportReviewUploadDto implements IImportReviewUploadDto {
    importedCount?: number;
    newCount?: number;
    exactDuplicateCount?: number;
    potentialDuplicateCount?: number;
    errors?: OfxParsingError[];

    constructor(data?: IImportReviewUploadDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.importedCount = _data["importedCount"];
            this.newCount = _data["newCount"];
            this.exactDuplicateCount = _data["exactDuplicateCount"];
            this.potentialDuplicateCount = _data["potentialDuplicateCount"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(OfxParsingError.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ImportReviewUploadDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImportReviewUploadDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["importedCount"] = this.importedCount;
        data["newCount"] = this.newCount;
        data["exactDuplicateCount"] = this.exactDuplicateCount;
        data["potentialDuplicateCount"] = this.potentialDuplicateCount;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IImportReviewUploadDto {
    importedCount?: number;
    newCount?: number;
    exactDuplicateCount?: number;
    potentialDuplicateCount?: number;
    errors?: OfxParsingError[];
}

export class OfxParsingError implements IOfxParsingError {
    message?: string;
    code?: string | undefined;
    fileName?: string | undefined;

    constructor(data?: IOfxParsingError) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            this.code = _data["code"];
            this.fileName = _data["fileName"];
        }
    }

    static fromJS(data: any): OfxParsingError {
        data = typeof data === 'object' ? data : {};
        let result = new OfxParsingError();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["code"] = this.code;
        data["fileName"] = this.fileName;
        return data;
    }
}

export interface IOfxParsingError {
    message?: string;
    code?: string | undefined;
    fileName?: string | undefined;
}

export abstract class PaginatedResultBaseDto implements IPaginatedResultBaseDto {
    pageNumber?: number;
    pageSize?: number;
    totalCount?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedResultBaseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.totalCount = _data["totalCount"];
            this.totalPages = _data["totalPages"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedResultBaseDto {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'PaginatedResultBaseDto' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["totalCount"] = this.totalCount;
        data["totalPages"] = this.totalPages;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedResultBaseDto {
    pageNumber?: number;
    pageSize?: number;
    totalCount?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class PaginatedResultDtoOfImportReviewTransactionDto extends PaginatedResultBaseDto implements IPaginatedResultDtoOfImportReviewTransactionDto {
    items?: ImportReviewTransactionDto[];

    constructor(data?: IPaginatedResultDtoOfImportReviewTransactionDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ImportReviewTransactionDto.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): PaginatedResultDtoOfImportReviewTransactionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedResultDtoOfImportReviewTransactionDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IPaginatedResultDtoOfImportReviewTransactionDto extends IPaginatedResultBaseDto {
    items?: ImportReviewTransactionDto[];
}

export class ImportReviewTransactionDto implements IImportReviewTransactionDto {
    key?: string;
    date?: Date;
    payee?: string;
    category?: string;
    amount?: number;
    duplicateStatus?: DuplicateStatus;
    duplicateOfKey?: string | undefined;

    constructor(data?: IImportReviewTransactionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : undefined as any;
            this.payee = _data["payee"];
            this.category = _data["category"];
            this.amount = _data["amount"];
            this.duplicateStatus = _data["duplicateStatus"];
            this.duplicateOfKey = _data["duplicateOfKey"];
        }
    }

    static fromJS(data: any): ImportReviewTransactionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImportReviewTransactionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["date"] = this.date ? formatDate(this.date) : undefined as any;
        data["payee"] = this.payee;
        data["category"] = this.category;
        data["amount"] = this.amount;
        data["duplicateStatus"] = this.duplicateStatus;
        data["duplicateOfKey"] = this.duplicateOfKey;
        return data;
    }
}

export interface IImportReviewTransactionDto {
    key?: string;
    date?: Date;
    payee?: string;
    category?: string;
    amount?: number;
    duplicateStatus?: DuplicateStatus;
    duplicateOfKey?: string | undefined;
}

export enum DuplicateStatus {
    New = 0,
    ExactDuplicate = 1,
    PotentialDuplicate = 2,
}

export class ImportReviewCompleteDto implements IImportReviewCompleteDto {
    acceptedCount?: number;
    rejectedCount?: number;

    constructor(data?: IImportReviewCompleteDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.acceptedCount = _data["acceptedCount"];
            this.rejectedCount = _data["rejectedCount"];
        }
    }

    static fromJS(data: any): ImportReviewCompleteDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImportReviewCompleteDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["acceptedCount"] = this.acceptedCount;
        data["rejectedCount"] = this.rejectedCount;
        return data;
    }
}

export interface IImportReviewCompleteDto {
    acceptedCount?: number;
    rejectedCount?: number;
}

/** Data transfer object for test user credentials including unique identifier */
export class TestUserCredentials implements ITestUserCredentials {
    /** The unique identifier (GUID) of the created user */
    id?: string;
    /** The username for authentication */
    username?: string;
    /** The email address for authentication */
    email?: string;
    /** The generated password for authentication */
    password?: string;

    constructor(data?: ITestUserCredentials) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.username = _data["username"];
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): TestUserCredentials {
        data = typeof data === 'object' ? data : {};
        let result = new TestUserCredentials();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["username"] = this.username;
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

/** Data transfer object for test user credentials including unique identifier */
export interface ITestUserCredentials {
    /** The unique identifier (GUID) of the created user */
    id?: string;
    /** The username for authentication */
    username?: string;
    /** The email address for authentication */
    email?: string;
    /** The generated password for authentication */
    password?: string;
}

export class TenantResultDto implements ITenantResultDto {
    key?: string;
    name?: string;
    description?: string;
    createdAt?: Date;

    constructor(data?: ITenantResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): TenantResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["name"] = this.name;
        data["description"] = this.description;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        return data;
    }
}

export interface ITenantResultDto {
    key?: string;
    name?: string;
    description?: string;
    createdAt?: Date;
}

/** Request to create a workspace for a test user. */
export class WorkspaceCreateRequest implements IWorkspaceCreateRequest {
    /** The name of the workspace (must include __TEST__ prefix). */
    name?: string;
    /** A description of the workspace. */
    description?: string;
    /** The role to assign to the user (default: Owner). */
    role?: string;

    constructor(data?: IWorkspaceCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.role = _data["role"];
        }
    }

    static fromJS(data: any): WorkspaceCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new WorkspaceCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["role"] = this.role;
        return data;
    }
}

/** Request to create a workspace for a test user. */
export interface IWorkspaceCreateRequest {
    /** The name of the workspace (must include __TEST__ prefix). */
    name?: string;
    /** A description of the workspace. */
    description?: string;
    /** The role to assign to the user (default: Owner). */
    role?: string;
}

/** Request to assign a user to an existing workspace. */
export class UserRoleAssignment implements IUserRoleAssignment {
    /** The role to assign to the user in the workspace. */
    role?: string;

    constructor(data?: IUserRoleAssignment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.role = _data["role"];
        }
    }

    static fromJS(data: any): UserRoleAssignment {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleAssignment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role;
        return data;
    }
}

/** Request to assign a user to an existing workspace. */
export interface IUserRoleAssignment {
    /** The role to assign to the user in the workspace. */
    role?: string;
}

export class TransactionResultDto implements ITransactionResultDto {
    key?: string;
    date?: Date;
    amount?: number;
    payee?: string;
    memo?: string | undefined;
    category?: string;

    constructor(data?: ITransactionResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : undefined as any;
            this.amount = _data["amount"];
            this.payee = _data["payee"];
            this.memo = _data["memo"];
            this.category = _data["category"];
        }
    }

    static fromJS(data: any): TransactionResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["date"] = this.date ? formatDate(this.date) : undefined as any;
        data["amount"] = this.amount;
        data["payee"] = this.payee;
        data["memo"] = this.memo;
        data["category"] = this.category;
        return data;
    }
}

export interface ITransactionResultDto {
    key?: string;
    date?: Date;
    amount?: number;
    payee?: string;
    memo?: string | undefined;
    category?: string;
}

/** Request to seed transactions in a workspace. */
export class TransactionSeedRequest implements ITransactionSeedRequest {
    /** Number of transactions to create. */
    count?: number;
    /** Prefix for payee names (default: "Test Transaction"). */
    payeePrefix?: string;
    /** Optional memo text to apply to all seeded transactions. */
    memo?: string | undefined;
    /** Optional source text to apply to all seeded transactions. */
    source?: string | undefined;
    /** Optional external ID text to apply to all seeded transactions. */
    externalId?: string | undefined;
    /** Optional category text to apply to all seeded transactions. */
    category?: string | undefined;

    constructor(data?: ITransactionSeedRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.count = _data["count"];
            this.payeePrefix = _data["payeePrefix"];
            this.memo = _data["memo"];
            this.source = _data["source"];
            this.externalId = _data["externalId"];
            this.category = _data["category"];
        }
    }

    static fromJS(data: any): TransactionSeedRequest {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionSeedRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        data["payeePrefix"] = this.payeePrefix;
        data["memo"] = this.memo;
        data["source"] = this.source;
        data["externalId"] = this.externalId;
        data["category"] = this.category;
        return data;
    }
}

/** Request to seed transactions in a workspace. */
export interface ITransactionSeedRequest {
    /** Number of transactions to create. */
    count?: number;
    /** Prefix for payee names (default: "Test Transaction"). */
    payeePrefix?: string;
    /** Optional memo text to apply to all seeded transactions. */
    memo?: string | undefined;
    /** Optional source text to apply to all seeded transactions. */
    source?: string | undefined;
    /** Optional external ID text to apply to all seeded transactions. */
    externalId?: string | undefined;
    /** Optional category text to apply to all seeded transactions. */
    category?: string | undefined;
}

/** Result of workspace setup including key, name, and assigned role. */
export class WorkspaceSetupResult implements IWorkspaceSetupResult {
    /** The unique identifier of the created workspace. */
    key?: string;
    /** The name of the workspace. */
    name?: string;
    /** The role assigned to the user. */
    role?: string;

    constructor(data?: IWorkspaceSetupResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.name = _data["name"];
            this.role = _data["role"];
        }
    }

    static fromJS(data: any): WorkspaceSetupResult {
        data = typeof data === 'object' ? data : {};
        let result = new WorkspaceSetupResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["name"] = this.name;
        data["role"] = this.role;
        return data;
    }
}

/** Result of workspace setup including key, name, and assigned role. */
export interface IWorkspaceSetupResult {
    /** The unique identifier of the created workspace. */
    key?: string;
    /** The name of the workspace. */
    name?: string;
    /** The role assigned to the user. */
    role?: string;
}

/** Request for setting up a workspace with a specific role. */
export class WorkspaceSetupRequest implements IWorkspaceSetupRequest {
    /** The name of the workspace. */
    name?: string;
    /** A description of the workspace. */
    description?: string;
    /** The role to assign to the user. */
    role?: string;

    constructor(data?: IWorkspaceSetupRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.role = _data["role"];
        }
    }

    static fromJS(data: any): WorkspaceSetupRequest {
        data = typeof data === 'object' ? data : {};
        let result = new WorkspaceSetupRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["role"] = this.role;
        return data;
    }
}

/** Request for setting up a workspace with a specific role. */
export interface IWorkspaceSetupRequest {
    /** The name of the workspace. */
    name?: string;
    /** A description of the workspace. */
    description?: string;
    /** The role to assign to the user. */
    role?: string;
}

/** Information about an error code available for testing */
export class ErrorCodeInfo implements IErrorCodeInfo {
    /** The error code to use in the query parameter */
    code?: string;
    /** Description of what error will be generated */
    description?: string;

    constructor(data?: IErrorCodeInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): ErrorCodeInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorCodeInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["description"] = this.description;
        return data;
    }
}

/** Information about an error code available for testing */
export interface IErrorCodeInfo {
    /** The error code to use in the query parameter */
    code?: string;
    /** Description of what error will be generated */
    description?: string;
}

export class PaginatedResultDtoOfString extends PaginatedResultBaseDto implements IPaginatedResultDtoOfString {
    items?: string[];

    constructor(data?: IPaginatedResultDtoOfString) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(item);
            }
        }
    }

    static override fromJS(data: any): PaginatedResultDtoOfString {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedResultDtoOfString();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IPaginatedResultDtoOfString extends IPaginatedResultBaseDto {
    items?: string[];
}

export class TransactionDetailDto implements ITransactionDetailDto {
    key?: string;
    date?: Date;
    amount?: number;
    payee?: string;
    memo?: string | undefined;
    source?: string | undefined;
    externalId?: string | undefined;
    category?: string;

    constructor(data?: ITransactionDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : undefined as any;
            this.amount = _data["amount"];
            this.payee = _data["payee"];
            this.memo = _data["memo"];
            this.source = _data["source"];
            this.externalId = _data["externalId"];
            this.category = _data["category"];
        }
    }

    static fromJS(data: any): TransactionDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["date"] = this.date ? formatDate(this.date) : undefined as any;
        data["amount"] = this.amount;
        data["payee"] = this.payee;
        data["memo"] = this.memo;
        data["source"] = this.source;
        data["externalId"] = this.externalId;
        data["category"] = this.category;
        return data;
    }
}

export interface ITransactionDetailDto {
    key?: string;
    date?: Date;
    amount?: number;
    payee?: string;
    memo?: string | undefined;
    source?: string | undefined;
    externalId?: string | undefined;
    category?: string;
}

export class TransactionEditDto implements ITransactionEditDto {
    date?: Date;
    amount?: number;
    payee?: string;
    memo?: string | undefined;
    source?: string | undefined;
    externalId?: string | undefined;
    category?: string | undefined;

    constructor(data?: ITransactionEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : undefined as any;
            this.amount = _data["amount"];
            this.payee = _data["payee"];
            this.memo = _data["memo"];
            this.source = _data["source"];
            this.externalId = _data["externalId"];
            this.category = _data["category"];
        }
    }

    static fromJS(data: any): TransactionEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? formatDate(this.date) : undefined as any;
        data["amount"] = this.amount;
        data["payee"] = this.payee;
        data["memo"] = this.memo;
        data["source"] = this.source;
        data["externalId"] = this.externalId;
        data["category"] = this.category;
        return data;
    }
}

export interface ITransactionEditDto {
    date?: Date;
    amount?: number;
    payee?: string;
    memo?: string | undefined;
    source?: string | undefined;
    externalId?: string | undefined;
    category?: string | undefined;
}

export class TransactionQuickEditDto implements ITransactionQuickEditDto {
    payee?: string;
    memo?: string | undefined;
    category?: string | undefined;

    constructor(data?: ITransactionQuickEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.payee = _data["payee"];
            this.memo = _data["memo"];
            this.category = _data["category"];
        }
    }

    static fromJS(data: any): TransactionQuickEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionQuickEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["payee"] = this.payee;
        data["memo"] = this.memo;
        data["category"] = this.category;
        return data;
    }
}

export interface ITransactionQuickEditDto {
    payee?: string;
    memo?: string | undefined;
    category?: string | undefined;
}

export class BaseModel implements IBaseModel {
    id?: number;
    key?: string;

    constructor(data?: IBaseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.key = _data["key"];
        }
    }

    static fromJS(data: any): BaseModel {
        data = typeof data === 'object' ? data : {};
        let result = new BaseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["key"] = this.key;
        return data;
    }
}

export interface IBaseModel {
    id?: number;
    key?: string;
}

export class WeatherForecast extends BaseModel implements IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    summary?: string | undefined;
    temperatureF?: number;

    constructor(data?: IWeatherForecast) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : undefined as any;
            this.temperatureC = _data["temperatureC"];
            this.summary = _data["summary"];
            this.temperatureF = _data["temperatureF"];
        }
    }

    static override fromJS(data: any): WeatherForecast {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherForecast();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? formatDate(this.date) : undefined as any;
        data["temperatureC"] = this.temperatureC;
        data["summary"] = this.summary;
        data["temperatureF"] = this.temperatureF;
        super.toJSON(data);
        return data;
    }
}

export interface IWeatherForecast extends IBaseModel {
    date?: Date;
    temperatureC?: number;
    summary?: string | undefined;
    temperatureF?: number;
}

export class TenantRoleResultDto implements ITenantRoleResultDto {
    key?: string;
    name?: string;
    description?: string;
    role?: TenantRole;
    createdAt?: Date;

    constructor(data?: ITenantRoleResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.role = _data["role"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): TenantRoleResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantRoleResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["name"] = this.name;
        data["description"] = this.description;
        data["role"] = this.role;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        return data;
    }
}

export interface ITenantRoleResultDto {
    key?: string;
    name?: string;
    description?: string;
    role?: TenantRole;
    createdAt?: Date;
}

export enum TenantRole {
    Viewer = 1,
    Editor = 2,
    Owner = 3,
}

export class TenantEditDto implements ITenantEditDto {
    name?: string;
    description?: string;

    constructor(data?: ITenantEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): TenantEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }
}

export interface ITenantEditDto {
    name?: string;
    description?: string;
}

function formatDate(d: Date) {
    return d.getFullYear() + '-' + 
        (d.getMonth() < 9 ? ('0' + (d.getMonth()+1)) : (d.getMonth()+1)) + '-' +
        (d.getDate() < 10 ? ('0' + d.getDate()) : d.getDate());
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}